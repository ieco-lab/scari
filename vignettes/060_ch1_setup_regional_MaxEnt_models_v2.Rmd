---
title: "Setup for invaded regional MaxEnt Models (chapter 1)"
author: "Samuel M. Owens"
contact: "sam.owens@temple.edu"
date: "2024-01-05"
output: html_document
---
# Overview

In the previous vignette, I ran the global model, which was an important first step to examine suitability for SLF at multiple spatial scales. In this vignette, I will set up to run a model at the regional scale of the Eastern USA. We hypothesize that by creating models at multiple spatial scales, we can have more confidence in suitability predictions made for specific SLF populations and important viticultural regions, and can predict the risk of specific populations spreading now vs under climate change.

This vignette will set up for the regional model in a similar fashion to the setup I created for the global model in vignette 040. Step 1 will involve cropping the bioclim layers to the proper extent and step 2 will involve choosing the background points for the regional model. Note that background point choice will be weighted by the output of the global model.

```{r extents table}

extents <- data.frame(
  "spatial_extent" = c("global model training", "invaded_regional model training", "native_regional model training", "projection"),
  "long_min" = c(-180, -96.504, 89.43514, -140.977),
  "long_max" = c(179, -59.590, 126.05626, -51.064),
  "lat_min" = c(-60, 23.5, 20.23827, 15.182),
  "lat_max" = c(83, 47.458, 53.32406, 60.589)
)

extents_kable <- knitr::kable(x = extents)
  
```

# Setup

I will prepare for this vignette by loading the necessary packages to run this script. I will also be creating maps during this analysis, so I will create a list object containing a standardized map style that I will continue to use.

```{r load necesssary packages, echo = FALSE}

# general tools
library(tidyverse)  #data manipulation
library(here) #making directory pathways easier on different instances
here() # here() starts at the root folder of this package.
library(devtools)

library(dismo) # generate random background points

# spatial data handling
library(raster) 
library(terra)
library(sf)

# spatial data sources
library(rnaturalearth)
# remotes::install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)

# aesthetics
# devtools::install_github("slowkow/ggrepel")
library(ggrepel)

```

```{r ggplot object for map style}

map_style <- list(
  xlab("longitude"),
  ylab("latitude"),
  theme_classic(),
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "lightblue",
                                colour = "lightblue")
        ),
  coord_equal() 
)

```

# 1. Trim Bioclim layers

## Invaded regional (eastern USA)

First, I will need to create a few copies of the bioclim layers that I tidied in vignette 030. I will create a set that have been cropped only to the eastern USA, which will be used to train the invaded regional models I produce. These rasters will be used for model training. In this chunk, I will extract the names and file paths for the desired rasters and set the extent. I am also cropping "access to cities" because some future models may include it.

```{r set wd}

# path to directory
  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

```{r setup for cropping bioclim layers}

# lists of target files in the directory
# load in bioclim layers to be cropped- the 10km .asc files
env.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = TRUE) %>%
# extract the 4 bioclim layers I will be using in my models. Access to cities will not be used until later models
  grep("atc_2015_global.asc|bio2_1981-2010_global.asc|bio11_1981-2010_global.asc|bio12_1981-2010_global.asc|bio15_1981-2010_global.asc", ., value = TRUE)

# output file names
output.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = FALSE) %>%
  grep("atc_2015_global|bio2_1981-2010_global|bio11_1981-2010_global|bio12_1981-2010_global|bio15_1981-2010_global", ., value = TRUE) %>%
  gsub(pattern = "global", replacement = "easternUSA")

# extent object for eastern USA
ext.obj <- terra::ext(-96.503906, -59.589844, 23.5, 47.457809)

```

These rasters need to be cropped and converted to the .ascii format for MaxEnt.

```{r loop to crop bioclim layers to eastern N america}

# view list of filetypes for terra, use .ascii
View(terra::gdal(drivers = TRUE))

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj, overwrite = FALSE)
    
    #write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

# I am pretty sure this method resets the raster cell numbers, which might be annoying downstream....

```

Lets plot one of the new layers to make sure the cropping worked.

```{r plot main_layer to ensure cropping worked}

bio11 <- terra::rast(x = file.path(mypath, "bio11_1981-2010_easternUSA.asc")) 
# convert to df
bio11_df <- terra::as.data.frame(bio11, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```

## Native regional (China)

### Get shapefile for native range

```{r rnaturalearth download}

# check which types of data are available
data(df_layers_cultural) 
# I will use states_provinces

# get metadata
ne_metadata <- ne_find_vector_data(
  scale = 10,
  category = "cultural",
  getmeta = TRUE
) %>%
  dplyr::filter(layer == "admin_1_states_provinces")
# URL to open metadata
utils::browseURL(ne_metadata[, 3])


# download data
china_provinces <- rnaturalearth::ne_download(
  scale = 10, # highest resolution
  type = "admin_1_states_provinces", # states and provinces
  category = "cultural",
  #destdir = file.path(here(), "data-raw", "ne_states_provinces"),
  #load = TRUE, # load into environment
  returnclass = "sf" #terra spatvector
)

```

```{r ready data for intersect}

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  sf::st_as_sf(coords = c("x", "y")) # convert to sf object

# set crs
sf::st_crs(slf_points) <- "EPSG:4326"
  


# china shapefile  
china_provinces <- china_provinces %>%
  dplyr::filter(geonunit == "China") %>%
  # set crs
  sf::st_transform(x = ., dst = "EPSG:4326") 

```


```{r intersect and save}

# intersect
china_provinces_withSLF <- sf::st_filter(x = china_provinces, y = slf_points)

# also retrieve bounding box for records
sf::st_bbox(china_provinces_withSLF)

# list of writing drivers for sf
sf::st_drivers()
# write to file
sf::st_write(
  obj = china_provinces_withSLF, 
  dsn = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"),
  driver = "ESRI Shapefile"
  )


```



```{r plot china}

(native_map <- ggplot() +
   # world map
   geom_polygon(data = map_data('world', region = "China"), aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # raster data
   geom_sf(data = china_provinces_withSLF, fill = "darkorange", color = "black") +
   # geom_sf_label(data = china_provinces_withSLF, aes(label = name), size = 2, position = "dodge") +
   ggrepel::geom_label_repel(
     data = china_provinces_withSLF, 
     aes(geometry = geometry, label = name), 
     stat = "sf_coordinates", 
     size = 3, 
     label.size = 0.75,
     linewidth = 1
     ) +
   xlab("longitude") +
   ylab("latitude") +
   labs(title = "Native range for SLF (Chinese provinces containing SLF records)") +
   theme_classic()
)
```

```{r save plot}

ggsave(native_map, 
       filename = file.path(here(), "vignette-outputs", "figures", "SLF_native_range_extent.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
)

```


This roughly corresponds to the survey performed by Xin et al. This study performed a rigorous survey of SLF populations across China for biocontrol purposes (Xin et al, 2020). [Here](https://academic.oup.com/view-large/figure/228296055/nvaa137_fig1.jpg) is a figure of the study sites where they retrieved SLF populations. They also mapped the population density to a map of the Chinese provinces [here](https://academic.oup.com/view-large/figure/228296047/nvaa137_fig6.jpg?itm_medium=graphical+abstract+image&itm_content=open+image&itm_source=http://academic.oup.com/ee/article/50/1/36/6029751&itm_campaign=graphical+abstract). Our map roughly corresponds to the native extent of SLF, as surveyed by this study. 

Another study by Du et al surveyed SLF populations to explain the phylogenetic origins of invasive SLF populations (Du et al, 2021). Du et al took measures to ensure that SLF populations surveyed for their study represented established populations and they specifically surveyed egg masses (Du et al, 2021). Our range map also corresponds to the map of surveyed populations in [figure 1](https://academic.oup.com/view-large/figure/228296047/nvaa137_fig6.jpg?itm_medium=graphical+abstract+image&itm_content=open+image&itm_source=http://academic.oup.com/ee/article/50/1/36/6029751&itm_campaign=graphical+abstract). 

Our native range map included two additional provinces, one in the far south (Guangdong) and one at the western edge (Qinghai). This is likely due to additional records that we retrieved from the literature in vignette 020. This range map will represent the native range training area for our native regional model. Background points will be chosen specifically from this region of China. Other countries have been named as part of the SLF native range (India, Vietnam, Taiwan, Bangaladesh), but no data exists to support these claims, so we chose to be conservative with our consideration of the SLF native range (SOURCE). Our consideration of the SLF native range also corresponds with the above mentioned surveys for SLF. 

*NOTE* inaturalist contains a single SLF presence in Taiwan, but this data point was not licensed for re-use and so we chose not to include it. Otherwise, no SLF presence data could be found in any data repository (GBIF, inaturalist) or the literature for the countries we chose to exclude from the SLF native range.

### Use shapefile to create rasters for SLF native range

I will use the above env.files and output.files objects to load in the bioclim rasters. I will then mask them using the shapefile I created in the last step.

```{r set wd}

  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

```{r load in data}

# load in shapefile as spatVector for compatibility
china_provinces_withSLF <- terra::vect(x = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"))

# rasters were loaded in above

# set naming for rasters
output.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = FALSE) %>%
  grep("atc_2015_global|bio2_1981-2010_global|bio11_1981-2010_global|bio12_1981-2010_global|bio15_1981-2010_global", ., value = TRUE) %>%
  gsub(pattern = "global", replacement = "China")

```

```{r mask}

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::mask(x = rast.hold, mask = china_provinces_withSLF)
    
    # write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

```

```{r plot for check}

bio11_china <- terra::rast(x = file.path(mypath, "bio11_1981-2010_China.asc")) 
# convert to df
bio11_china_df <- terra::as.data.frame(bio11_china, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_china_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```

# 2. Background point choice

## Invaded Regional (eastern USA)

Gallien et.al found that the regional model performed better when the background point were weighted by the output of the global model. So, as part of the preparation for creating the regional model, we need to create a background dataset (just like we did for the global model), but we also need to weight those points by the cloglog suitability output from the global model. However, the SDMtune package does not allow weights to be attributed to pseudo-absences in the MaxEnt algorithm (nor do any packages I have seen, Gallien was performing other types of models that may integrate this function.). So, my work-around is to apply a weighting formula to the entire suitability raster from the global model and choose the background points based on this weight. The end result should be that there are more points selected where suitability for SLF is lower. 

Gallien et.al provided the following inverse logarithmic weighting formula:

$$
weight = \frac{1}{1 + (\frac{suitG}{suitG-1})^2}
$$

"suitG" indicates the suitability value in the global model. I will apply this formula to the mean suitability output from the global model.

To do that, I will use the `terra::app` function to convert the global mean raster to a list of suitability values at the cell value level. Then I will use the `dismo::randomPoints()` function again, but will give it the raster of weighted suitability values so that it chooses values according to the weight. 

First I will load in the global raster output. I will also load in the slf_points dataset for sampling

```{r set wd}

# path to directory
mypath <- file.path(here() %>% 
                     dirname(),
                   "maxent")

```


```{r load in global model predictions}

# load in averaged global output
global_mean <- terra::rast(x = file.path(mypath, "models", "slf_global_v1", "global_pred_suit_clamped_cloglog_NAmerica_1981-2010_mean.asc"))
# also convert to df
global_mean_df <- terra::as.data.frame(global_mean, xy = TRUE)

# slf points
slf_points <- read.csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
   dplyr::select(-species) 

# mask layer I will use
mask_layer <- raster::raster(x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_NAmerica.asc"))

```

Now I need to transform each raster cell according to the weighting formula. I wrote a function to do this called `slfSpread::weight_model_output`.

```{r apply weighting function}

global_mean_weighted <- terra::app(
  x = global_mean,
  fun = slfSpread::weight_model_output
)

# get name
names(global_mean_weighted)
# change layer name
names(global_mean_weighted) <- "weight"

```

```{r save}

# write to file
terra::writeRaster(
  x = global_mean_weighted, 
  filename = file.path(mypath, "models", "slf_global_v1", "global_pred_suit_clamped_cloglog_NAmerica_1981-2010_mean_weighted.asc"),
  filetype = "AAIGrid",
  overwrite = FALSE
  )

```

The function will also work on numbers, so I can just give it a range of decimals from 0-1. It should nearly reverse the values if it is working properly. The minmax of each raster should be about 0-1. 

```{r validation}

# this function acts like a math formula, so it should work on numbers. It should work to reverse the order of values from 0 - 1. A 1 suitability should be a 0 weighted suitability
weight_model_output(1)
weight_model_output(0.6)
weight_model_output(0.4)
weight_model_output(0)

# the minmax should also be 0 - 1 in both cases
minmax(global_mean)
minmax(global_mean_weighted)

```

Now, I will sample the raster. I will still correct for the latitudinal stretching of the grid cells and exclude cells containing presences, as before. First, I will need to load in the rasters using the `raster` package for `dismo` compatibility.

```{r load weighted raster and crop}
 
# ext object for eastern USA
ext.obj <- raster::extent(-96.503906, -59.589844, 23.5, 47.457809)

# I will load in the raster and crop it to the training area extent.
global_mean_weighted <- raster::raster(
  x = file.path(mypath, "models", "slf_global_v1", "global_pred_suit_clamped_cloglog_NAmerica_1981-2010_mean_weighted.asc")
  ) %>%
  raster::mask(x = ., mask = mask_layer) %>%
  raster::crop(x = ., y = ext.obj) # crop to EasternUSA

  
# also conver to df
global_mean_weighted_df <- raster::as.data.frame(global_mean_weighted, xy = TRUE)

```

```{r random points}

# set seed
set.seed(5)

# generate random points 
regional_points <- dismo::randomPoints(
  mask = global_mean_weighted, 
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  prob = TRUE,  # the raster contains probability weights
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(x = regional_points, file = file.path(here(), "vignette-outputs", "data-tables", "regional_invaded_background_points_v1.csv"))
# save as rds file
write_rds(regional_points, file = file.path(here(), "data", "regional_invaded_background_points_v1.rds"))

```

Now lets visualize the result.

```{r load in raster for plotting}

easternUSA <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_easternUSA.asc")
  )

# also convert to df
easternUSA_df <- terra::as.data.frame(easternUSA, xy = TRUE)

```


```{r plot}

# plot at the continental scale
(regional_points_plot <- ggplot() +
   geom_raster(data = global_mean_df, aes(x = x, y = y), fill = "azure4") +
   geom_raster(data = easternUSA_df, aes(x = x, y = y), fill = "azure1") +
   geom_point(data = regional_points, aes(x = x, y = y), color = "darkorange", size = 0.10) +
   ggtitle("Regional background points") +
   map_style +
   theme(legend.position = "none") 
)

# plot of just the eastern USA
# LITERALLY no clue why this plot isnt working
#(regional_points_plot2 <- ggplot() +
#    geom_raster(data = global_mean_weighted_df, aes(x = x, y = y), fill = "azure1") +
#    geom_point(data = regional_points, aes(x = x, y = y), color = "darkorange", size = 0.10) +
#    ggtitle("regional_invaded Background Points") +
#    map_style +
#    theme(legend.position = "none") 
#)

```

We can see that the background points are isolated to the eastern half of the United States and some of Canada. This is what we want because the model will be trained on this area. We can also see that points were selected from areas where the model did not predict high suitability (most highly suitable areas were near PA and NJ). For comparison, this figure is roughly opposite of the figure depicting the suitability values for the mean output from the global model.  


```{r save plot}

ggsave(regional_points_plot, 
       filename = file.path(here(), "vignette-outputs", "figures", "regional_invaded_background_points_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
       )

#ggsave(regional_points_plot2, 
 #      filename = file.path(here(), "vignette-outputs", "figures", "regional_background_points2.jpg"),
  #     height = 8, 
  #     width = 10,
 #      device = "jpeg",
 #      dpi = "retina"
 #      )

```

## Native regional (China)







# Appendix

### Trim CMIP6 rasters to Eastern USA

```{r setup for cropping bioclim layers}

# path to directory
  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/future_climate_rasters/chelsa2.1_30arcsec/2041-2070_ssp370_GFDL")

# lists of target files in the directory
# load in bioclim layers to be cropped- the 10km .asc files
env.files <- list.files(path = file.path(mypath, "v1_maxent_10km"), pattern = "\\.asc$", full.names = TRUE) %>%
# extract the 4 bioclim layers I will be using in my models. Access to cities will not be used until later models
  grep("bio2_2041-2070_gfdl_370_global.asc|bio11_2041-2070_gfdl_370_global.asc|bio12_2041-2070_gfdl_370_global.asc|bio15_2041-2070_gfdl_370_global.asc", ., value = TRUE)

# output file names
output.files <- list.files(path = file.path(mypath, "v1_maxent_10km"), pattern = "\\.asc$", full.names = FALSE) %>%
  grep("bio2_2041-2070_gfdl_370_global.asc|bio11_2041-2070_gfdl_370_global.asc|bio12_2041-2070_gfdl_370_global.asc|bio15_2041-2070_gfdl_370_global.asc", ., value = TRUE) %>%
  gsub(pattern = "global", replacement = "easternUSA")

# extent object for eastern USA
ext.obj <- terra::ext(-96.503906, -59.589844, 23.5, 47.457809)

```

```{r loop to crop bioclim layers to eastern N america}

# view list of filetypes for terra, use .ascii
View(terra::gdal(drivers = TRUE))

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj, overwrite = FALSE)
    
    #write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, "v1_maxent_10km", output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

# I am pretty sure this method resets the raster cell numbers, which might be annoying downstream....

```

Lets plot one of the new layers to make sure the cropping worked.

```{r plot main_layer to ensure cropping worked}

bio11 <- terra::rast(x = file.path(mypath, "v1_maxent_10km", "bio11_2041-2070_gfdl_370_easternUSA.asc")) 
# convert to df
bio11_df <- terra::as.data.frame(bio11, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_2041-2070_gfdl-esm4_ssp370_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```


# References

D.D Calvin, J. Rost, J. Keller, S. Crawford, Julie Urban, B. Walsh, and M. Bosold. Seasonal Activity of Spotted Lanternfly, Lycorma delicatula (White) (Hemiptera: Fulgoridae), in Southeast Pennsylvania. Unpublished.

Du, Z., Y. Wu, Z. Chen, L. Cao, T. Ishikawa, S. Kamitani, T. Sota, F. Song, L. Tian, W. Cai, and H. Li. 2021. Global phylogeography and invasion history of the spotted lanternfly revealed by mitochondrial phylogenomics. Evolutionary Applications.

Gallien, L., R. Douzet, S. Pratte, N. E. Zimmermann, and W. Thuiller. 2012. Invasive species distribution models – how violating the equilibrium assumption can create new insights. Global Ecology and Biogeography 21:1126–1136.

Lewkiewicz, S. M., S. De Bona, M. R. Helmus, and B. Seibold. 2022. Temperature sensitivity of pest reproductive numbers in age-structured PDE models, with a focus on the invasive spotted lanternfly. Journal of Mathematical Biology 85:29.

Santana Jr, P. A., L. Kumar, R. S. Da Silva, J. L. Pereira, and M. C. Picanço. 2019. Assessing the impact of climate change on the worldwide distribution of Dalbulus maidis (DeLong) using MaxEnt. Pest Management Science 75:2706–2715.

Xin, B., Y. Zhang, X. Wang, L. Cao, K. A. Hoelmer, H. J. Broadley, and J. R. Gould. 2020. Exploratory survey of spotted lanternfly (Hemiptera: Fulgoridae) and its natural enemies in China. Environmental Entomology 50:36–45.




---
title: "Setup for regional MaxEnt Models"
author: "Samuel M. Owens"
contact: "sam.owens@temple.edu"
date: "2024-01-04"
output: html_document
---
# Overview

In the previous vignette, I ran the global model, which was an important first step to examine suitability for SLF at multiple spatial scales. In this vignette, I will set up to run two models at the spatial scale of particular regions. I will run two models; one model will be run based on data from the native range (China) and the other will be based on data from the invaded range in North America. We hypothesize that by creating models at multiple spatial scales, we can have more confidence in suitability predictions made for specific SLF populations and important viticultural regions, and can predict the risk of specific populations spreading now and under climate change.

(EXPAND)

This vignette will set up for the regional model in a similar fashion to the setup I created for the global model in vignette 040. Step 1 will involve cropping the bioclim layers to the proper extent and step 2 will involve choosing the background points for each regional model. Note that background point choice for the regional_invaded model will be weighted by the output of the global model, but the background point choice for the regional_native model will not be. This is to account for the fact that SLF have likely not had ample time to spread to all suitable areas within the invaded range. MaxEnt assumes that all training areas (in our case, the eastern USA) are equally as likely to host lanternfly, whereas we know this is not the case because SLF was introduced to this region within the past decade. Weighting our regional predictions with a prediction made using all available data should offset this incorrect assumption.

Here is the table summarizing the model structures:

```{r model_info table}

model_info <- data.frame(
  "model" = c(
    "regional_native",
    "regional_invaded",
    "regional_invaded_asian"
    ),
  "train_test_method" = c(
    "trained on east asia / tested on N America",
    "trained on N America / tested on east asia",
    "trained on Korea & Japan / tested on N America"
  ),
  "train_presences" = c(
    241,
    328,
    200
  ),
  "test_presences" = c(
    328,
    241,
    328
  ),
  "background_points" = c(
    "10,000",
    "10,000",
    "10,000"
  )
)

# convert to kable
model_info_kable <- knitr::kable(x = model_info) %>%
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)

```

# Setup

I will prepare for this vignette by loading the necessary packages to run this script. I will also be creating maps during this analysis, so I will create a list object containing a standardized map style that I will continue to use.

```{r load necesssary packages, echo = FALSE}

# general tools
library(tidyverse)  #data manipulation
library(here) #making directory pathways easier on different instances
here::here() # here() starts at the root folder of this package.
library(devtools)

library(dismo) # generate random background points

# spatial data handling
library(raster) 
library(terra)
library(sf)

# spatial data sources
library(rnaturalearth)
# remotes::install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)
library(kgc) # koppen climate rasters

# aesthetics
library(webshot2)
library(kableExtra)
library(patchwork)
library(gridExtra)

```

```{r save tables from above, if desired}

if(FALSE) {
  
  # model training dataset
  # save as .csv
  write_csv(model_info, file.path(here::here(), "vignette-outputs", "data-tables", "regional_ensemble_models_info.csv"))
  
  # save as .html
  kableExtra::save_kable(
    model_info_kable, 
    file = file.path(here::here(), "vignette-outputs", "figures", "regional_ensemble_models_info.html"),
    self_contained = TRUE,
    bs_theme = "simplex"
    )
  
  # initialize webshot by 
 # webshot::install_phantomjs()
  # convert to pdf
  webshot::webshot(
    url = file.path(here::here(), "vignette-outputs", "figures", "regional_ensemble_models_info.html"),
    file = file.path(here::here(), "vignette-outputs", "figures", "regional_ensemble_models_info.png")
  )
  
  # model extents
    
}

```

```{r ggplot object for map style}

map_style <- list(
  xlab("longitude"),
  ylab("latitude"),
  theme_classic(),
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
  ),
  scale_x_continuous(expand = c(0, 0)),
  scale_y_continuous(expand = c(0, 0)),
  labs(fill = "Suitability for SLF"),
  viridis::scale_fill_viridis(option = "D"),
  coord_equal()
)

```

# 1. Trim Bioclim layers

```{r set wd}

# path to directory
  mypath <- file.path(here::here() %>% 
                       dirname(),
                     "maxent")

```

```{r layers to be cropped}

# lists of target files in the directory
# load in bioclim layers to be cropped- the 10km .asc files
env.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\.asc$", full.names = TRUE) %>%
# extract the 4 bioclim layers I will be using in my models. Access to cities will not be used until later models
  grep("atc_2015_global.asc|bio2_1981-2010_global.asc|bio11_1981-2010_global.asc|bio12_1981-2010_global.asc|bio15_1981-2010_global.asc", ., value = TRUE)


```

I will also download the Koppen climate zones, which I will use to clip the bioclim layers.

```{r download koppen climate data}
 
# get data
kmz_data <- kgc::kmz

# generate coordinates
kmz_lat <- kgc::genCoords(latlon = "lat", full = TRUE)
kmz_lon <- kgc::genCoords(latlon = "lon", full = TRUE)

# join
kmz_data <- cbind(kmz_lat, kmz_lon) %>%
  cbind(., kmz_data) %>%
  as.data.frame() %>%
  # relocate column
  dplyr::select(kmz_lon, everything()) 



# convert to raster
kmz_data_rast <- terra::rast(
  x = kmz_data,
  type = "xyz",
  crs = "EPSG:4326"
  )
# change name of layer
names(kmz_data_rast) <- "Koeppen_climate_zone"

# validity- minmax should range between 0-32
minmax(kmz_data_rast)

```

```{r retrieve names for codes and make factor}

# retrieve names
kmz_names <- kgc::getZone(1:32)
# make facor levels
kmz_names_factor <- factor(
  x = kmz_names,
  levels = unique(kmz_names),
  ordered = TRUE
)

```


I will need to tidy these data by aggregating them to spatial scale I use for the bioclim variables. I will do this using the mode, because this variable is a set of numbers representing a categorical, so I do not want to average or take the median.

```{r tidy and resample new raster}

# layer used to aggregate raster
agg_layer <- terra::rast(file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_global.asc"))
# raster stats
terra::origin(agg_layer)
terra::crs(agg_layer)

# resample
koppen_zones_rast <- terra::resample(
  x = kmz_data_rast,
  y = agg_layer, # aggregate to this origin and resolution
  method = "mode",
  threads = TRUE,
  filename = file.path(mypath, "models", "working_dir", "koeppen_climate_zones.asc"),
  filetype = "AAIGrid", 
  overwrite = FALSE
    )

```

```{r visualize}

koeppen_zones_rast <- terra::rast(x = file.path(mypath, "models", "working_dir", "koeppen_climate_zones.asc"))
# origin
terra::origin(koeppen_zones_rast)
# convert to df
koeppen_zones_rast_df <- terra::as.data.frame(koeppen_zones_rast, xy = TRUE)

# plot main layer as example
(KG_climate_map <- ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = koeppen_zones_rast_df, 
            aes(x = x, y = y, fill = as.factor(koeppen_climate_zones))) +
    labs(
      title = "Koeppen-Geiger Climate Zones", 
      x = "longitude",
      y = "latitude",
      fill = "K-G climate zone number"
    ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  viridis::scale_fill_viridis(
    discrete = TRUE,
    aesthetics = "fill",
    option = "H",
    direction = -1,
    labels = kmz_names_factor
    ) +
  guides(fill = guide_legend(nrow = 3)) +
  theme_classic() +
  theme(legend.position = "bottom") +
  coord_equal()
)


```

```{r save plot}

ggsave(KG_climate_map, 
       filename = file.path(here::here(), "vignette-outputs", "figures", "koeppen_climate_zones.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
)

```

I will also write this raster to a shapefile for easy selection of climate zones.

```{r write to shapefile}

# next, convert raster to polygon
KG_zones_invaded_poly <- terra::as.polygons(
  x = koeppen_zones_rast,
  aggregate = TRUE,
  values = TRUE,
  crs = "EPSG:4326"
) 

gdal(drivers=TRUE)

# write to shapefile
terra::writeVector(
  x = KG_zones_invaded_poly,
  filename = file.path(mypath, "models", "working_dir", "shapefiles", "koeppen_climate_zones.shp"),
  filetype = "ESRI Shapefile",
  overwrite = TRUE
)

```

## Invaded regional (eastern USA)

First, I will overlay SLF presence points and use these to select which climate regions to keep. I will use these to create a reference layer. Then, I will use this layer to mask the layers that have already been cropped to N America.

### Select K-G climate regions

```{r import datasets}

koeppen_zones_rast <- terra::rast(x = file.path(mypath, "models", "working_dir", "koeppen_climate_zones.asc")) 

slf_points <- read_csv(file.path(here::here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
  dplyr::select(-species) 

```

I just want the presences from the invaded range

```{r filter presences from invaded range}

# extent object for North America
ext.obj <- terra::ext(-140.976563, -51.064453, 15.182421, 60.586967)

# convert to vector
slf_points_vect <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
  # crop by extent area of interest
  terra::crop(., y = ext.obj) %>%
  # convert to geom, which gets coordinates of a spatVector
  terra::geom() 

# convert back to data frame
slf_points_invaded <- terra::as.data.frame(slf_points_vect) %>%
  dplyr::select(-c(geom, part, hole)) %>%
  sf::st_as_sf(coords = c("x", "y"), crs = "EPSG:4326")

# will not need this object again
rm(slf_points_vect)

```

Now we will intersect the points with the shapefile. I need to crop the shapefile to the the same extent as the presences and then intersect them to keep the climate zones that contain presences. The resulting shapefile will be used to crop the bioclim data and choose background points for that specific model.

```{r intersect slf points with shapefile}

# load in shapefile again
KG_zones_invaded_poly <- sf::read_sf(dsn = file.path(mypath, "models", "working_dir", "shapefiles", "koeppen_climate_zones.shp")) %>%
  dplyr::rename("koeppen_climate_zones" = "koeppen_cl")

# bounding box for cropping
ext.obj.vect <- c(xmin = -140.976563, ymin = 15.182421, xmax = -51.064453, ymax = 60.586967)
# first, crop K-G raster to N America
KG_zones_invaded_poly <- st_crop(KG_zones_invaded_poly, y = ext.obj.vect) %>%
  # also get rid of ocean
  dplyr::filter(koeppen_climate_zones != 32)




# intersect
regional_invaded_withSLF <- sf::st_filter(x = KG_zones_invaded_poly, y = slf_points_invaded)

# write to file
sf::st_write(
  obj = regional_invaded_withSLF, 
  dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_extent.shp"),
  driver = "ESRI Shapefile",
  append = FALSE
  )

```

```{r re-load}

regional_invaded_withSLF <- sf::read_sf(dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_extent.shp")) %>%
  dplyr::rename("koeppen_climate_zones" = "kppn_c_")


# get extent
st_bbox(regional_invaded_withSLF) 

```

Now lets plot it for a sanity check.

```{r plot invaded_asian range}

(regional_invaded_withSLF_plot <- ggplot() +
   # world map
   geom_polygon(data = map_data('world', region = c("Canada", "USA", "Mexico", "Guatemala", "Honduras", "El Salvador", "Nicaragua", "Bahamas", "Cuba", "Costa Rica", "Haiti", "Dominican Republic", "Jamaica", "Bermuda")), aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # slf native range shapefile
   geom_sf(data = regional_invaded_withSLF, aes(fill = as.factor(koeppen_climate_zones)), color = "black") +
   # scales
   labs(
     title = "Koeppen climate zones used to choose background points for 'regional_invaded' model",
     caption = "K-G zones selected if containing SLF presences within North America",
     x = "longitude",
     y = "latitude",
     fill = "Koeppen climate zone"
     ) +
   scale_fill_brewer(palette = "Paired", labels = kmz_names_factor) +
   theme_classic() +
   theme(legend.position = "right") +
   coord_sf(xlim = c(-140.976563, -51.064453), ylim = c(15.182421, 60.586967))
)

```

```{r save plot}

ggsave(
  regional_invaded_withSLF_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "SLF_regional_invaded_extent_KG_climate_zones.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
)

```

So when we mask the bioclim layers, we should see something similar to this.

### Mask bioclim layers

```{r setup for cropping bioclim layers}

# import layers
env.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_NAmerica.asc$", full.names = TRUE) 

# output file names
output.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_NAmerica.asc$", full.names = FALSE) %>%
  gsub(pattern = "NAmerica", replacement = "regional_invaded_KG")

# also load shapefile again
regional_invaded_withSLF <- terra::vect(file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_extent.shp")) 

# for cropping
ext.obj.crop <- terra::ext(-138.66681, 19.12534, -52.58347, 60.83319 , xy = TRUE)

```

I will now mask these rasters using the shapefile created above

```{r loop to crop bioclim layers to NAmerica invaded range}

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # mask new rasters using shapefile
    rast.hold <- terra::mask(x = rast.hold, mask = regional_invaded_withSLF, overwrite = FALSE)
        # crop to extent as well
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj.crop, overwrite = FALSE)
    
    #write out the new resampled rasters!
    terra::writeRaster(
      x = rast.hold, 
      filename = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", output.files[a]), 
      filetype = "AAIGrid", 
      overwrite = FALSE
      )
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

# I am pretty sure this method resets the raster cell numbers, which might be annoying downstream....

```

Lets plot one of the new layers to make sure the cropping worked.

```{r plot main_layer to ensure cropping worked}

bio11 <- terra::rast(x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "bio11_1981-2010_regional_invaded_KG.asc")) 
# convert to df
bio11_df <- terra::as.data.frame(bio11, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```

```{r remove objects}

rm(ext.obj)
rm(ext.obj.vect)
rm(ext.obj.crop)

```

## Invaded regional (South Korea and Japan)

I need to find a way to clip the climate zones by native vs invaded region, because the same climate zones are likely present in Japan and Korea as in the native range. However, I want to segment the data by region. I would normally use the country administrative borders, but there are many contested islands that would be left out. So, I will obtain the bounding box for Japan and south korea and use that to geographically segment the KG climate zones before masking.

### Select K-G climate regions

```{r import datasets}

koeppen_zones_rast <- terra::rast(x = file.path(mypath, "models", "working_dir", "koeppen_climate_zones.asc")) 

slf_points <- read_csv(file.path(here::here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
  dplyr::select(-species) 

```

I just want the presences from the invaded range. I will manually filter out some points that accidentally got into both the native and regional_invaded_asian models.

```{r filter presences from invaded range}

# extent object for Japan and SK
ext.obj <- terra::ext(122.93816, 153.98561, 24.21210, 45.52041)

# convert to vector
slf_points_vect <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
  # crop by extent area of interest
  terra::crop(., y = ext.obj) %>%
  # convert to geom, which gets coordinates of a spatVector
  terra::geom() 

# convert to sf object
slf_points_invaded_asian <- terra::as.data.frame(slf_points_vect) %>%
  dplyr::select(-c(geom, part, hole)) %>%
  # filter out specific points that were showing up in both native and invaded_regional model
  dplyr::filter(x > 125) %>%
  # convert to sf object
  sf::st_as_sf(coords = c("x", "y"), crs = "EPSG:4326") 

# will not need this object again
rm(slf_points_vect)

```

Now we will intersect the points with the shapefile. I need to crop the shapefile to the the same extent as the presences and then intersect them to keep the climate zones that contain presences. The resulting shapefile will be used to crop the bioclim data and choose background points for that specific model.

```{r intersect slf points with shapefile}

# load in shapefile again
KG_zones_invaded_asian_poly <- sf::read_sf(dsn = file.path(mypath, "models", "working_dir", "shapefiles", "koeppen_climate_zones.shp")) %>%
  dplyr::rename("koeppen_climate_zones" = "koeppen_cl")

# bounding box for cropping
ext.obj.vect <- c(xmin = 122.93816, ymin = 24.21210, xmax = 153.98561, ymax = 45.52041)
# first, crop K-G raster to SK and Japan
KG_zones_invaded_asian_poly <- st_crop(KG_zones_invaded_asian_poly, y = ext.obj.vect) %>%
  # also get rid of ocean
  dplyr::filter(koeppen_climate_zones != 32)




# intersect
regional_invaded_asian_withSLF <- sf::st_filter(x = KG_zones_invaded_asian_poly, y = slf_points_invaded_asian)

# write to file
sf::st_write(
  obj = regional_invaded_asian_withSLF, 
  dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"),
  driver = "ESRI Shapefile",
  append = FALSE
  )

```

```{r re-load}

regional_invaded_asian_withSLF <- sf::read_sf(dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp")) %>%
  dplyr::rename("koeppen_climate_zones" = "kppn_c_")

# get extent
st_bbox(regional_invaded_asian_withSLF) 

```

Now lets plot it for a sanity check.

```{r plot invaded_asian range}

(regional_invaded_asian_withSLF_plot <- ggplot() +
   # world map
   geom_polygon(data = map_data('world', region = c("Japan", "North Korea", "China", "South Korea", "Russia", "Mongolia")), aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # slf native range shapefile
   geom_sf(data = regional_invaded_asian_withSLF, aes(fill = as.factor(koeppen_climate_zones)), color = "black") +
   # scales
   labs(
     title = "Koeppen climate zones used to choose background points for 'regional_invaded_asian' model",
     caption = "K-G zones selected if containing SLF presences within invaded asian range",
     x = "longitude",
     y = "latitude",
     fill = "Koeppen climate zone"
     ) +
   scale_fill_brewer(palette = "Paired", labels = kmz_names_factor) +
   theme_classic() +
   theme(legend.position = "right") +
   coord_sf(xlim = c(122.93816, 153.98561), ylim = c(24.21210, 45.52041))
)

```

```{r save plot}

ggsave(
  regional_invaded_asian_withSLF_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "SLF_regional_invaded_asian_extent_KG_climate_zones.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
)

```

### Mask bioclim layers

```{r load in data}

# bioclim layers
env.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_global.asc$", full.names = TRUE) 

# set naming for rasters
output.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_global.asc$", full.names = FALSE) %>%
  gsub(pattern = "global", replacement = "regional_invaded_asian_KG")



# load in shapefile as spatVector 
regional_invaded_asian_withSLF <- terra::vect(x = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"))

# for cropping
ext.obj.crop <- terra::ext(122.93816, 30.49986, 149.74986, 46.58424, xy = TRUE)

```

```{r mask}

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::mask(x = rast.hold, mask = regional_invaded_asian_withSLF)
    # crop to extent as well
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj.crop, overwrite = FALSE)
    
    # write out the new resampled rasters!
    terra::writeRaster(
      x = rast.hold, 
      filename = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", output.files[a]), 
      filetype = "AAIGrid", 
      overwrite = FALSE
      )
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

```

```{r plot for check}

bio11_invaded_asian <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "bio11_1981-2010_regional_invaded_asian_KG.asc")
  ) 
# convert to df
bio11_invaded_asian_df <- terra::as.data.frame(bio11_invaded_asian, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_invaded_asian_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```
```{r remove objects}

rm(ext.obj)
rm(ext.obj.vect)
rm(ext.obj.crop)

```


Looks good!

## Native regional (China)

The native range for China will be defined as anywhere within Southeast asia that contains the same climate zones that SLF are found in within east asia. We will first need to download shapefiles for each of the countries in southeast asia. We will use these shapefiles to clip our KG climate zones shapefile. Then, we will use that final shapefile to clip the bioclim rasters.

### Get shapefile for native range

```{r rnaturalearth download}

# check which types of data are available
# these are in the rnaturalearth package
data(df_layers_cultural) 
# I will use states_provinces

# get metadata
ne_metadata <- ne_find_vector_data(
  scale = 10,
  category = "cultural",
  getmeta = TRUE
) %>%
  dplyr::filter(layer == "admin_0_countries")
# URL to open metadata
utils::browseURL(ne_metadata[, 3])


# download data
asia_sf <- rnaturalearth::ne_download(
  scale = 10, # highest resolution
  type = "admin_0_countries", # states and provinces
  category = "cultural",
  destdir = file.path(here::here(), "data-raw", "ne_countries"),
  load = TRUE, # load into environment
  returnclass = "sf" # shapefile
)

```

Now that we have the data, we can cut out the parts we want. We can treat the shapefile like any other data table and simply retrieve the countries we want. We will keep all countries in southeast asia, plus countries in south asia excluding Pakistan and Afghanistan and east asia excluding the invaded range in asia (Japan, SK, NK) (Wikipedia, see references). We are using a much larger extent because there is a lot of conjecture about the true native range of SLF, and we want those climate zones to be considered. 

```{r select countries and save}

# southeast asia shapefile
asia_sf <- asia_sf %>%
  # filter all countries in southeast asia
  dplyr::filter(
    NAME %in% c(
      # southeast asia
      "Brunei", "East Timor", "Indonesia", "Laos", "Malaysia", "Myanmar", "Philippines", "Singapore", "Thailand", "Vietnam", 
      # east asia
      "China", "Hong Kong", "Macau", "Mongolia", "Taiwan", 
      # south asia
      "Bangladesh", "Bhutan", "India", "Maldives", "Nepal", "Sri Lanka")
    ) %>%
  # set crs
  sf::st_transform(x = ., dst = "EPSG:4326") 

# save
sf::st_write(
  obj = asia_sf, 
  dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "asia_admin.shp"),
  driver = "ESRI Shapefile"
  )

```

Macau and Hong Kong did not show up in the original dataset, but were likely considered part of a larger country (in the case of Hong Kong, China).

We will use this shapefile to cut out the KG climate zones, then will intersect the result with the SLF points dataset

### Select KG regions

I will import the slf presences and KG shapefile first. 

```{r import datasets}

# slf presences
slf_points <- read_csv(file.path(here::here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
  dplyr::select(-species) 

# load in KG shapefile 
koeppen_zones_rast <- terra::rast(file.path(mypath, "models", "working_dir", "koeppen_climate_zones.asc")) 

# re-load asia admin shapefile
asia_vect <- terra::vect(file.path(here::here(), "vignette-outputs", "shapefiles", "asia_admin.shp"))

```

Next, I will crop the SLF presences and the KG shapefile datasets using the asias range shapefile.

```{r crop KG sf by asian sf}

# temp mask layer
mask_layer <- vect(asia_sf)
# convert to vector
slf_points_masked <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
# crop by extent area of interest
terra::mask(., mask = mask_layer) %>%
# convert to geom, which gets coordinates of a spatVector
terra::geom() 

# convert back to data frame
slf_points_native <- terra::as.data.frame(slf_points_masked) %>%
  dplyr::select(-c(geom, part, hole)) %>%
  sf::st_as_sf(coords = c("x", "y"), crs = "EPSG:4326")
  
# will not need these objects again
rm(slf_points_masked)
rm(mask_layer)

```

```{r crop KG raster by asian vector}

# first, mask K-G raster by asian countries
koeppen_zones_rast_native <- terra::mask(koeppen_zones_rast, mask = asia_vect) 

# next, convert raster to polygon
KG_zones_native_poly <- terra::as.polygons(
  x = koeppen_zones_rast_native,
  aggregate = TRUE,
  values = TRUE,
  crs = "EPSG:4326"
) 

# write to shapefile
terra::writeVector(
  x = KG_zones_native_poly,
  filename = file.path(mypath, "models", "working_dir", "shapefiles", "asia_admin_KG.shp"),
  filetype = "ESRI Shapefile",
  overwrite = TRUE
)

```

```{r intersect and save}

# load back in as shapefile
KG_zones_native_poly <- sf::read_sf(dsn = file.path(mypath, "models", "working_dir", "shapefiles", "asia_admin_KG.shp")) %>%
  # rename
  dplyr::rename("koeppen_climate_zones" = "koeppen_cl") %>%
  # also get rid of ocean
  dplyr::filter(koeppen_climate_zones != 32) 
  
# intersect
regional_native_withSLF <- sf::st_filter(x = KG_zones_native_poly, y = slf_points_native)


# write to file
sf::st_write(
  obj = regional_native_withSLF, 
  dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_native_extent.shp"),
  driver = "ESRI Shapefile",
  append = FALSE
  )

```

```{r re-load shapefile as needed}

regional_native_withSLF <- sf::read_sf(dsn = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_native_extent.shp")) %>%
  dplyr::rename("koeppen_climate_zones" = "kppn_c_")

# get extent
st_bbox(regional_native_withSLF) 

```

Now lets plot it for a sanity check.

```{r plot china}

(regional_native_withSLF_plot <- ggplot() +
  geom_polygon(
    data = map_data('world', region = c("Brunei", "East Timor", "Indonesia", "Laos", "Malaysia", "Myanmar", "Philippines", "Singapore", "Thailand", "Vietnam", "China", "Hong Kong", "Macau", "Mongolia", "Taiwan","Bangladesh", "Bhutan", "India", "Maldives", "Nepal", "Sri Lanka")), 
    aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # slf native range shapefile
   geom_sf(data = regional_native_withSLF, aes(fill = as.factor(koeppen_climate_zones)), color = "black") +
   # scales
   labs(
     title = "Koeppen climate zones used to choose background points for 'regional_native' model",
     caption = "K-G zones selected if containing SLF presences within native range",
     x = "longitude",
     y = "latitude",
     fill = "Koeppen climate zone"
     ) +
   scale_fill_brewer(palette = "Paired", labels = kmz_names_factor) +
   theme_classic() +
   theme(legend.position = "right") +
   coord_sf()
)
```

```{r save plot}

ggsave(
  regional_native_withSLF_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "SLF_native_extent_KG_climate_zones.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
)

```

### Mask bioclim layers

```{r setup for cropping bioclim layers}

# import layers
env.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_global.asc$", full.names = TRUE) 

# output file names
output.files <- list.files(path = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km"), pattern = "\\_global.asc$", full.names = FALSE) %>%
  gsub(pattern = "global", replacement = "regional_native_KG")

# also load shapefile again
regional_native_withSLF <- terra::vect(file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_native_extent.shp")) 

ext.obj.crop <- terra::ext(72.666527, -9.666806, 140.999860, 53.249861, xy = TRUE)

```

I will now mask these rasters using the shapefile created above

```{r loop to crop bioclim layers to NAmerica invaded range}

if(TRUE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # mask new rasters using shapefile
    rast.hold <- terra::mask(x = rast.hold, mask = regional_native_withSLF, overwrite = FALSE)
    # crop to extent as well
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj.crop, overwrite = FALSE)
    
    #write out the new resampled rasters!
    terra::writeRaster(
      x = rast.hold, 
      filename = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", output.files[a]), 
      filetype = "AAIGrid", 
      overwrite = FALSE
      )
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

# I am pretty sure this method resets the raster cell numbers, which might be annoying downstream....

```

Lets plot one of the new layers to make sure the cropping worked.

```{r plot main_layer to ensure cropping worked}

bio11_native <- terra::rast(x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "bio11_1981-2010_regional_native_KG.asc")) 
# convert to df
bio11_native_df <- terra::as.data.frame(bio11_native, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_native_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```

```{r remove objects}

rm(ext.obj.crop)

```


We will need to select background points for all three regional models, which we will do next.

# 2. Background point choice

```{r set wd}

  mypath <- file.path(here::here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

## Invaded Regional (eastern USA)

```{r load datasets}

# load in raster to choose points from
regional_invaded_bio11 <- raster::raster(x = file.path(mypath, "bio11_1981-2010_regional_invaded_KG.asc")) 

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here::here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  as.data.frame()

```

Now, select random points. These will be corrected for the latitudinal stretching and will not be selected from presence locations, like with the global model. 

```{r random points}

# set seed
set.seed(5)

# generate random points 
regional_invaded_background <- dismo::randomPoints(
  mask = regional_invaded_bio11, # cropped to eastern USA
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(
  x = regional_invaded_background, 
  file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_background_points_unweighted_v6.csv")
  )
# save as rds file
write_rds(
  regional_invaded_background, 
  file = file.path(here::here(), "data", "regional_invaded_background_points_unweighted_v6.rds")
  )

```

Now lets visualize the result.

```{r plotting datasets}

# plotting raster
regional_invaded_bio11_df <- terra::rast(x = file.path(mypath, "bio11_1981-2010_regional_invaded_KG.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

# re-read background points 
regional_invaded_background <- read.csv(file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_background_points_unweighted_v6.csv"))

# extent object for N America
ext.obj <- terra::ext( -140.976563, -51.064453, 15.182421, 60.586967)

# load in raster for visualization
global_atc <- terra::rast(x = file.path(mypath, "atc_2015_global.asc")) %>%
  # crop to easternUSA
  terra::crop(., y = ext.obj)
# convert to df
global_atc_df <- terra::as.data.frame(global_atc, xy = TRUE)

```


```{r plot}

# plot at the continental scale
(regional_invaded_background_plot <- ggplot() +
   geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
   geom_raster(data = regional_invaded_bio11_df, aes(x = x, y = y), fill = "azure1") +
   geom_point(data = regional_invaded_background, aes(x = x, y = y), color = "firebrick2", size = 0.1) +
   scale_x_continuous(expand = c(0, 0)) +
   scale_y_continuous(expand = c(0, 0)) +
   labs(
     title = "'regional_invaded' model background points", 
     x = "longitude",
     y = "latitude"
     ) +
   theme_classic() +
   theme(
     legend.position = "none",
     panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
     ) + 
   coord_equal() 
)

```

We can see that the background points are isolated to the eastern half of the United States and some of Canada. This is what we want because the model will be trained on this area. We can also see that points were selected from areas where the model did not predict high suitability (most highly suitable areas were near PA and NJ). For comparison, this figure is roughly opposite of the figure depicting the suitability values for the mean output from the global model.  

```{r save plot}

ggsave(
  regional_invaded_background_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_invaded_model_background_points_unweighted_v6.jpg"),
  height = 8, 
  width = 12,
  device = "jpeg",
  dpi = "retina"
  )

```


## invaded Regional (South Korea and Japan)

```{r load datasets}

# load in raster to choose points from
invaded_asian_bio11 <- raster::raster(x = file.path(mypath, "bio11_1981-2010_regional_invaded_asian_KG.asc")) 

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here::here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  as.data.frame()

```

```{r random points}

# set seed
set.seed(7)

# generate random points 
regional_invaded_asian_points <- dismo::randomPoints(
  mask = invaded_asian_bio11, # cropped to regional_invaded_asian range
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(x = regional_invaded_asian_points, file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_asian_background_points_unweighted_v1.csv"))
# save as rds file
write_rds(regional_invaded_asian_points, file = file.path(here::here(), "data", "regional_invaded_asian_background_points_unweighted_v1.rds"))

```

Now lets visualize the result.

```{r load in data for plotting}

invaded_asian_bio11_df <- terra::rast(
  x = file.path(mypath, "bio11_1981-2010_regional_invaded_asian_KG.asc")
  ) %>%
  terra::as.data.frame(., xy = TRUE)

global_atc_df <- terra::rast(x = file.path(mypath, "atc_2015_global.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

regional_invaded_asian_points <- read.csv(file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_asian_background_points_unweighted_v1.csv"))

```

```{r plot}

(regional_invaded_asian_points_plot <- ggplot() +
   geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
   geom_raster(data = invaded_asian_bio11_df, aes(x = x, y = y), fill = "azure1") +
   geom_point(data = regional_invaded_asian_points, aes(x = x, y = y), color = "firebrick2", size = 0.1) +
   ggtitle("'regional_invaded_asian' model background points") +
   map_style +
   theme(legend.position = "none") +
   coord_equal(xlim = c(122, 153.98561), ylim = c(24.21210, 47))
)



```

We can see that the background points are isolated to the eastern half of the United States and some of Canada. This is what we want because the model will be trained on this area. We can also see that points were selected from areas where the model did not predict high suitability (most highly suitable areas were near PA and NJ). For comparison, this figure is roughly opposite of the figure depicting the suitability values for the mean output from the global model.  

```{r save plot}

ggsave(regional_invaded_asian_points_plot, 
       filename = file.path(
         here::here(), "vignette-outputs", "figures", "regional_invaded_asian_model_background_points_unweighted_v1.jpg"
         ),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
       )

```


## Native regional (China)

I need to select points for China as well, but I do not need to weight these. The background selection here will be random, but will still exclude cells with SLF points and will correct for latitudinal stretching.

```{r set wd}

# path to directory
mypath <- file.path(here::here() %>% 
                     dirname(),
                   "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

```{r load in datasets}

# slf points
slf_points <- read.csv(file = file.path(here::here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
   dplyr::select(-species) 

# mask layer I will use
regional_native_bio2 <- raster::raster(x = file.path(mypath, "bio2_1981-2010_regional_native_KG.asc")) # %>%
  #!is.na()

# also get ext
terra::ext(regional_native_bio2)

```

```{r background points for global models}

# set seed so that the random points for this dataset are the same the next time this code is run
set.seed(6)
# generate random points 
regional_native_points <- dismo::randomPoints(
  mask = regional_native_bio2, 
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(x = regional_native_points, 
          file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_native_background_points_unweighted_v2.csv")
          )
# save as rds file
write_rds(regional_native_points, 
          file = file.path(here::here(), "data", "regional_native_background_points_unweighted_v2.rds")
          )
  
  
```

Now, I will plot these points for visualization purposes.

```{r load in files for plotting}

regional_native_bio2_df <- terra::rast(x = file.path(mypath, "bio2_1981-2010_regional_native_KG.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

regional_native_points <- read_csv(file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_native_background_points_unweighted_v2.csv"))

global_atc_df <- terra::rast(x = file.path(mypath, "atc_2015_global.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

```

```{r plot points}

(regional_native_points_plot <- ggplot() +
  geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = regional_native_bio2_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = regional_native_points, aes(x = x, y = y), color = "firebrick2", size = 0.1) +
  ggtitle("'regional_native' model background points") +
  map_style +
  theme(legend.position = "none")  +
  coord_equal(xlim = c(72.666527, 140.999860), ylim = c(-9.666806, 53.249861))
)

```

The points seem to sufficiently cover the global extent. I can also see the latitude weighting, as the areas nearest the poles are less densely covered with points than areas near the equator.

```{r save plot}

ggsave(regional_native_points_plot, 
       filename = file.path(here::here(), "vignette-outputs", "figures", "regional_native_model_background_points_unweighted_v2.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

# 3. Choose and plot presence points

```{r set wd}

  mypath <- file.path(here::here() %>% 
                       dirname(),
                     "maxent")

```

```{r read in data}

global_atc_df <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_global.asc")
  ) %>%
  terra::as.data.frame(., xy = TRUE)

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here::here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) 

```

## Invaded Regional 

Finally, I will create a plot of all SLF presence locations for reference.

```{r filter presences from invaded range}

# extent object for eastern USA
ext.obj <- terra::ext(-96.503906, -59.589844, 23.5, 47.457809)

# convert to vector
slf_points_vect <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
  # crop by extent area of interest
  terra::crop(., y = ext.obj) %>%
  # convert to geom, which gets coordinates of a spatVector
  terra::geom() 

# convert back to data frame
slf_points_invaded <- terra::as.data.frame(slf_points_vect) %>%
  dplyr::select(-c(geom, part, hole))

# will not need this object again
rm(slf_points_vect)

```

```{r save presences}

write_csv(
  x = slf_points_invaded,
  file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_model_presence_points_v6.csv")
)

```

```{r plot model presences}

# load in raster
regional_invaded <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_regional_invaded_KG.asc")
  )
# also convert to df
regional_invaded_df <- terra::as.data.frame(regional_invaded, xy = TRUE)

# plot
regional_invaded_slf_plot <- ggplot() +
  geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = regional_invaded_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_invaded, aes(x = x, y = y), color = "darkorange", size = 0.5) +
  labs(
    title = "'regional_invaded' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal(xlim = c(-140.976563, -51.064453), ylim = c(15.182421, 60.586967))
  

```

```{r save plot}

ggsave(
  regional_invaded_slf_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_invaded_model_presence_points_v6.jpg"),
  height = 8, 
  width = 12,
  device = "jpeg",
  dpi = "retina"
  )

```

## Invaded Regional (South Korea and Japan)

```{r filter presences from invaded_asian range}

# native range extent shapefile used to select slf presences
mask_layer <- terra::vect(x = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"))

# convert to vector
slf_points_masked <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
# crop by extent area of interest
terra::mask(., mask = mask_layer) %>%
# convert to geom, which gets coordinates of a spatVector
terra::geom() 

# convert back to data frame
slf_points_invaded_asian <- terra::as.data.frame(slf_points_masked) %>%
  dplyr::select(-c(geom, part, hole)) %>%
    dplyr::filter(x > 125)
  
# will not need this object again
rm(slf_points_masked)

```

```{r save presences}

write_csv(
  x = slf_points_invaded_asian,
  file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_invaded_asian_model_presence_points_v1.csv")
)

```

```{r plot model presences}

invaded_asian <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_regional_invaded_asian_KG.asc")
  )
# also convert to df
invaded_asian_df <- terra::as.data.frame(invaded_asian, xy = TRUE)

regional_invaded_asian_slf_plot <- ggplot() +
  geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = invaded_asian_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_invaded_asian, aes(x = x, y = y), color = "darkorange", size = 1) +
  labs(
    title = "'regional_invaded_asian' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal(xlim = c(122, 153.98561), ylim = c(24.21210, 47))
  

```

```{r save plot}

ggsave(
  regional_invaded_asian_slf_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_invaded_asian_model_presence_points_v1.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

## Native Regional

```{r filter presences from native range}

# native range extent shapefile used to select slf presences
mask_layer <- terra::vect(x = file.path(here::here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"))

# convert to vector
slf_points_masked <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
# crop by extent area of interest
terra::mask(., mask = mask_layer) %>%
# convert to geom, which gets coordinates of a spatVector
terra::geom() 

# convert back to data frame
slf_points_native <- terra::as.data.frame(slf_points_masked) %>%
  dplyr::select(-c(geom, part, hole))
  
# will not need this object again
rm(slf_points_masked)
rm(mask_layer)

```

```{r save presences}

write_csv(
  x = slf_points_native,
  file = file.path(here::here(), "vignette-outputs", "data-tables", "regional_native_model_presence_points_v2.csv")
)

```

```{r plot model presences}

regional_native <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_regional_native_KG.asc")
  )
# also convert to df
regional_native_df <- terra::as.data.frame(regional_native, xy = TRUE)

regional_native_slf_plot <- ggplot() +
  geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = regional_native_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_native, aes(x = x, y = y), color = "darkorange", size = 1) +
  labs(
    title = "'regional_native' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal(xlim = c(72.666527, 140.999860), ylim = c(-9.666806, 53.249861))
  

```

```{r save plot}

ggsave(
  regional_native_slf_plot, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_native_model_presence_points_v2.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

Now we are ready to run both regional models!

# Patchwork together figures

I will put the figures together for publication

```{r regional_invaded}

x_scale_labels <- c(-140, -120, -100, -80, -60)
y_scale_labels <- c(20, 30, 40, 50, 60)

regional_invaded_withSLF_plot <- regional_invaded_withSLF_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background point area") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 




regional_invaded_background_plot <- regional_invaded_background_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 


  
regional_invaded_slf_plot  <- regional_invaded_slf_plot +
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "presence points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 



regional_invaded_patchwork <- (regional_invaded_slf_plot + regional_invaded_background_plot) / (regional_invaded_withSLF_plot + plot_spacer())
  plot_annotation(title = "'regional_invaded' model elements") 

  # work around because collect axes not working
regional_invaded_patchwork <- patchwork::patchworkGrob(regional_invaded_patchwork) %>%
  gridExtra::grid.arrange(left = "latitude", bottom = "longitude")

```

```{r save plot}

ggsave(
  regional_invaded_patchwork, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_invaded_model_summary.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

```{r regional_invaded_asian}

x_scale_labels <- c(130, 140, 150)
y_scale_labels <- c(25, 30, 35, 40, 45)

regional_invaded_asian_withSLF_plot <- regional_invaded_asian_withSLF_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background point area") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 


regional_invaded_asian_points_plot <- regional_invaded_asian_points_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 

  
regional_invaded_asian_slf_plot  <- regional_invaded_asian_slf_plot +
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "presence points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 




regional_invaded_asian_patchwork <- (regional_invaded_asian_slf_plot + regional_invaded_asian_points_plot) / (regional_invaded_asian_withSLF_plot + plot_spacer()) +
  plot_annotation(title = "'regional_invaded_asian' model elements") 

# work around because collect axes not working
regional_invaded_asian_patchwork <- patchwork::patchworkGrob(regional_invaded_asian_patchwork) %>%
  gridExtra::grid.arrange(left = "latitude", bottom = "longitude")

```

```{r save plot}

ggsave(
  regional_invaded_asian_patchwork, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_invaded_asian_model_summary.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```


```{r regional_native}

x_scale_labels <- c(80, 100, 120, 140)
y_scale_labels <- c(0, 10, 20, 30, 40, 50)

regional_native_withSLF_plot <- regional_native_withSLF_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background point area") +
  scale_x_continuous(labels = seq(from = 70, to = 140, by = 10), breaks = seq(from = 70, to = 140, by = 10), expand = c(0, 0)) +
  scale_y_continuous(labels = c(-10, 0, 10, 20, 30, 40, 50), breaks = c(-10, 0, 10, 20, 30, 40, 50), expand = c(0, 0)) 


regional_native_points_plot <- regional_native_points_plot + 
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "background points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 

  
regional_native_slf_plot  <- regional_native_slf_plot +
  theme(
    plot.subtitle = element_blank(),
    plot.caption = element_blank(),
    axis.title = element_blank()
    ) +
  labs(title = "presence points") +
  scale_x_continuous(labels = x_scale_labels, breaks = x_scale_labels, expand = c(0, 0)) +
  scale_y_continuous(labels = y_scale_labels, breaks = y_scale_labels, expand = c(0, 0)) 




regional_native_patchwork <- (regional_native_slf_plot | regional_native_points_plot) / (regional_native_withSLF_plot | plot_spacer()) +
  plot_annotation(title = "'regional_native' model elements") 

# work around because collect axes not working
regional_native_patchwork <- patchwork::patchworkGrob(regional_native_patchwork) %>%
  gridExtra::grid.arrange(left = "latitude", bottom = "longitude")

```

```{r save plot}

ggsave(
  regional_native_patchwork, 
  filename = file.path(here::here(), "vignette-outputs", "figures", "regional_native_model_summary.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

# References

Calvin, D. D., J. Rost, J. Keller, S. Crawford, B. Walsh, M. Bosold, and J. Urban. 2023. Seasonal activity of spotted lanternfly (Hemiptera: Fulgoridae), in Southeast Pennsylvania. Environmental Entomology 52:1108–1125.

Du, Z., Y. Wu, Z. Chen, L. Cao, T. Ishikawa, S. Kamitani, T. Sota, F. Song, L. Tian, W. Cai, and H. Li. 2021. Global phylogeography and invasion history of the spotted lanternfly revealed by mitochondrial phylogenomics. Evolutionary Applications.

Gallien, L., R. Douzet, S. Pratte, N. E. Zimmermann, and W. Thuiller. 2012. Invasive species distribution models – how violating the equilibrium assumption can create new insights. Global Ecology and Biogeography 21:1126–1136.

Lewkiewicz, S. M., S. De Bona, M. R. Helmus, and B. Seibold. 2022. Temperature sensitivity of pest reproductive numbers in age-structured PDE models, with a focus on the invasive spotted lanternfly. Journal of Mathematical Biology 85:29.

Santana Jr, P. A., L. Kumar, R. S. Da Silva, J. L. Pereira, and M. C. Picanço. 2019. Assessing the impact of climate change on the worldwide distribution of Dalbulus maidis (DeLong) using MaxEnt. Pest Management Science 75:2706–2715.

East Asia. 2024, March 6. Wikipedia.

South Asia. 2024, March 27. Wikipedia.

Southeast Asia. 2024, March 27. Wikipedia.

Xin, B., Y. Zhang, X. Wang, L. Cao, K. A. Hoelmer, H. J. Broadley, and J. R. Gould. 2020. Exploratory survey of spotted lanternfly (Hemiptera: Fulgoridae) and its natural enemies in China. Environmental Entomology 50:36–45.





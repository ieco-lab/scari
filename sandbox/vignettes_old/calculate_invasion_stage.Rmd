---
title: "Analysis of SLF invasion stage and models based on Gallien et.al, 2012 methodology"
author: "Samuel M. Owens"
contact: "sam.owens@temple.edu"
date: "2023-08-09"
output: html_document
---

# Overview

In this vignette, I will compare known SLF presences with the predicted SLF suitability to infer an "invasion stage" for each point. This will be done by extracting the predicted suitability values at each known SLF point from both models. I will then binarize these rasters (suitable/unsuitable) and use these versions to infer the level of range filling and invasion stage of the points. I ran two trial models, v5_global and v5_regional that will be used to build this analysis. 

For my analysis, I need to compare the predictions of both the regional and global models in the invaded region. I will begin by comparing the performance of each model at each point across the invaded range. Gallien et.al did this for both observed presences and pseudo-absences ("background points"), but in this vignette I will only use known SLF presences. The extracted values of the points were used to produce a boxplot of predicted suitability for the global vs the regional model. I will create a boxplot of the values and plot the points over the rasters

Next, I will need to infer the amount of range filling and invasion stage of SLF according to each model. In Gallien et.al, this was done by binarizing each raster and overlaying them. The raster values are summed I will then overlay known SLF presences.  There are a few steps to this process:

1. Create suitable vs unsuitable classes based on the range of values in each raster (likely the suitability threshold rule chosen in MaxEnt, MTP).
2. Convert each output to binary (suitable/unsuitable) based on these suitability thresholds 
2. Mosaic the rasters and sum their values.
2. Re-classify summed raster as areas where both agree on presence, both agree on absence, or one classifies and the other classifies absent (4 total categories)

Finally, we will calculate the sensitivity and specificity of each model manually.

1. Calculate sensitivity (proportion of presences correctly guessed) for each model
2. calculate specificity (proportion of absences correctly guessed) for each model

THIS IS WHERE THE 0.5 THRESHOLD COMES IN
METHODS PENDING

# Setup

```{r load necesssary packages, echo = FALSE}

library(tidyverse)

library(here) 
# here() is set at the root folder of this package

library(terra)
library(RColorBrewer)

# install.packages("tidygeocoder")
library(tidygeocoder) # this package allows me to match lat/lon data to an address

```

I will create lists of ggplot options that I will append to figures to save typing.

```{r ggplot object for map style}

map_style <- list(
  xlab("longitude"),
  ylab("latitude"),
  theme_classic(),
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "lightblue",
                                colour = "lightblue")
        ),
  coord_equal() 
)

```

```{r ggplot object for plot style}

# a vector to rescale the axes of the plots
breaks <- c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)

scatter_style <- list(
  scale_x_continuous(name = "suitability in global model", limits = c(0, 1), breaks = breaks),
  scale_y_continuous(name = "suitability in regional model", limits = c(0, 1), breaks = breaks),
  theme_minimal()
)

```

I will also load in the data needed.

```{r load in SLF data, echo = FALSE}

slf_points <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_v0_2023-07.csv")) %>%
  dplyr::select(!species) # species column not necessary in this analysis
  
```

```{r load in rasters}

# path to directory I will be working in
mypath <- file.path(here::here() %>%  
                      dirname(),
                    "maxent/models")

# load in regional model
v5_regional1 <- terra::rast(x = file.path(mypath, "maxent_slf_gbif_v5_regional", "Lycorma_delicatula_avg.asc"))

# load in global model
v5_global1 <- terra::rast(x = file.path(mypath, "maxent_slf_gbif_v5_global", "Lycorma_delicatula_avg.asc"))

# rename values
names(v5_regional1) <- "v5_regional"
names(v5_global1) <- "v5_global"

```

I will crop the global model just to N America because this raster requires a lot of computing power to process at such a high resolution.

```{r crop v5_global}

ext.obj <- terra::ext(-133.593750, -52.294922, 25.085599, 55.304138)

v5_global1 <- terra::crop(x = v5_global1, y = ext.obj)

```

# Extract SLF point-wise suitability

I will stack the rasters and extract values from both layers that can be used to create a scatter plot. First, I will perform this process for our list of known SLF points, then I will repeat it for a list of IVRs (important viticultural regions) obtained from Huron et.al, 2022. These lat/long data represent the most important regions globally for viticulture.

## Known SLF presences

```{r extract point values}

if(FALSE) {
  
  # create raster stack
  v5_stack <- c(v5_regional1, v5_global1)
  
  # extract values
  slf_suitability <- terra::extract(x = v5_stack, 
                                    y = slf_points, 
                                    cells = TRUE, # get cell #s
                                    xy = TRUE, # get coordinates
                                    ID = TRUE # give ID column
                                    ) 

}

```

```{r tidy suitability df}

slf_suitability <- slf_suitability %>%
  filter(!is.na(v5_regional) | !is.na(v5_global), # I want to keep NAs that are only in 1 column
         !is.nan(x) | !is.nan(y)) # these NaNs are data points outside the raster extent (native range)

# convert NAs that are only in one model to 0
slf_suitability$v5_regional[is.na(slf_suitability$v5_regional)] <- 0
slf_suitability$v5_global[is.na(slf_suitability$v5_global)] <- 0

```

```{r save suitability values}

write_csv(slf_suitability, file = file.path(here(), "vignette-outputs", "data-tables", "slf_suitability_maxent_v5.csv"))

# also save as a .rda file
save(slf_suitability, file = file.path(here(), "data", "slf_suitability_maxent_v5.rda"))

```

Now that the values have been extracted, lets plot them.

```{r plot SLF suitability values}

slf_suitability <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_suitability_maxent_v5.csv"))

(slf_suitability_scatter <- ggplot() +
    geom_vline(xintercept = 0.5) + # midpoint line
    geom_vline(xintercept = 0.163, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in global model
    geom_hline(yintercept = 0.5) +  # midpoint line
    geom_hline(yintercept = 0.079, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in regional model
    geom_point(data = slf_suitability, 
               aes(x = v5_global, y = v5_regional), 
               color = "darkorange", size = 1) +
    ggtitle("suitability of known SLF points in global vs regional model") +
    labs(caption = "dashed lines represent the minimum suitablity threshold") +
    scatter_style
)

```

```{r save scatterplot}

ggsave(slf_suitability_scatter, filename = file.path(here(), "vignette-outputs", "figures", "slf_suitability_maxent_v5_plot_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

(interpretation)

## IVRs

Now, we will repeat the process for our list of IVRs (wineries) in the data folder, called `wineries.Rda`.

```{r load IVR (winery) data}

load(file = file.path(here(), "data", "wineries.rda"))

```

```{r extract point values}

if(FALSE){

  IVR_points <- wineries %>%
    dplyr::select(x, y)
  
  # extract values
  IVR_suitability <- terra::extract(x = v5_stack, 
                                    y = IVR_points, 
                                    cells = TRUE, # get cell #s
                                    xy = TRUE, # get coordinates
                                    ID = TRUE # give ID column
                                    ) 
  
}

```

```{r tidy suitability df}

IVR_suitability <- IVR_suitability %>%
  filter(!is.na(v5_regional) | !is.na(v5_global), # I want to keep NAs that are only in 1 column
         !is.nan(x) | !is.nan(y)) # these NaNs are data points outside the raster extent (native range)

# convert NAs that are only in one model to 0
IVR_suitability$v5_regional[is.na(IVR_suitability$v5_regional)] <- 0
IVR_suitability$v5_global[is.na(IVR_suitability$v5_global)] <- 0

```

```{r save suitability values}

write_csv(IVR_suitability, file = file.path(here(), "vignette-outputs", "data-tables", "IVR_suitability_maxent_v5.csv"))

# also save as a .rda file
save(IVR_suitability, file = file.path(here(), "data", "IVR_suitability_maxent_v5.rda"))

```

Now that the values have been extracted, lets plot them.

```{r plot SLF suitability values}

IVR_suitability <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "IVR_suitability_maxent_v5.csv"))

(IVR_suitability_scatter <- ggplot() +
    geom_vline(xintercept = 0.5) + # midpoint line
    geom_vline(xintercept = 0.163, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in global model
    geom_hline(yintercept = 0.5) +  # midpoint line
    geom_hline(yintercept = 0.079, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in regional model
    geom_point(data = IVR_suitability, 
               aes(x = v5_global, y = v5_regional), 
               color = "darkviolet", size = 1) +
    ggtitle("suitability of IVR regions for SLF establishment in global vs regional models") +
    labs(caption = "dashed lines represent the minimum suitablity threshold") +
    scatter_style
)

```

```{r save scatterplot}

ggsave(IVR_suitability_scatter, filename = file.path(here(), "vignette-outputs", "figures", "IVR_suitability_maxent_v5_plot_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

(Interpretation)

## Plot points over SLF model

Here, I will plot the IVRs (purple) and known SLF points (orange) over the v5 version of the global model I produced.

```{r plot SLF suitability values}

# plot with IVR and SLF points
v5_global_IVR_SLF <- ggplot() +
  geom_raster(data = terra::as.data.frame(v5_global1, xy = TRUE), 
              aes(x = x, y = y, fill = v5_global)) +
  geom_point(data = slf_points, 
             aes(x = x, y = y, color = "SLF populations"), size = 0.1, show.legend = TRUE) +
  geom_point(data = IVR_points, 
             aes(x = x, y = y, color = "IVR regions"), size = 0.1, show.legend = TRUE) +
  xlim(-133.593750, -52.294922) +
  ylim(25.085599, 55.304138) +
  scale_fill_distiller(name = "suitability for SLF", palette = "Greys", type = "seq", direction = 1) +
  scale_color_manual(name = "Point Data", values = c("SLF populations" = "darkorange", "IVR regions" = "darkviolet")) +
  guides(color = guide_legend(ncol = 1, byrow = TRUE, override.aes = list(size = 3))) +
  labs(title = "Contemporary SLF suitability in global model with IVR locations") +
  map_style

```

```{r save map}

ggsave(v5_global_IVR_SLF, filename = file.path(here(), "vignette-outputs", "figures", "v5_global_IVR_SLF.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```












# infer level of range filling

First, I will create matrix objects that will be used to reclassify the output rasters to a binary predictor of suitability. 0.5 will be the threshold: anything above 0.5 will be considered suitable, while anything below will not be. This threshold is essential for my invasion stage anaylsis further downstream.

To reclassify, package terra takes a 3-column matrix for its "classify" function, which re-classifies groups of values to other values. I will create one for the global model output and one for the regional model output. The reason for having two separate matrices is because I will need to differentiate between a "suitable" spot on the global and regional rasters. Because of this, I will be encoding the rasters into base-2 binary so that the end result is 4 categories of values (the idea for this was found in [this forum](https://gis.stackexchange.com/questions/127055/comparing-and-finding-inaccuracies-in-two-raster-layers)). For the regional raster, I will encode the logistical output of MaxEnt into these values:

*Regional unsuitable = 0-0.079 -> 00000001 = 1
*Regional suitable = 0.0791-1 ->  00000010 = 2

For the global rasters, I will encode the outputs into these values:

*Global unsuitable = 0-0.163 -> 00000100 = 4
*Global suitable = 0.1631-1 ->  00001000 = 8

By encoding the rasters into base-2, I have created only 4 possible values of the raster layers, which can be translated into 4 categories:

*Unsuitable Agreement = 5 (00000101)
*Suitable Agreement = 10 (00001010)
*unsuitable regional/suitable global = 9 (00001001)
*Suitable regional/unsuitable global = 6 (00000110)

### 1. convert output rasters to binary predictors

To convert the rasters to binary predictors of presence / absence, first I will create the classification matrices needed by the `terra` package.






Before converting, lets check the range of values

```{r minmax of rasters}

# get the range of the values in the raster
terra::minmax(v5_regional1) %>%
  format(., scientific = FALSE) # convert scientific notation to decimals


# get the range of the values in the raster
terra::minmax(v5_global1) %>%
  format(., scientific = FALSE)

# the values go from negative to positive infinity, which is an issue. So we will change our global classes to reflect this

```

Now I will create the classification rasters. The lower range of what is considered suitable will be determined by the "Maximum Test Sensitivity Plus Specificity" threshold given in the Maxent output. For the regional model, the mean threshold value was 0.079, while the mean value was 0.163 in the global model.

```{r terra required classification matrices}

# create regional suitability value matrix for terra
regional_classes <- data.frame(
  from = c(0, 0.0791),
  to = c(0.079, 1),
  becomes = c(strtoi(00000001, base = 2), strtoi(00000010, base = 2)) # the strtoi function converts to base-2
)

global_classes <- data.frame(
  from = c(0, 0.1631),
  to = c(0.163, 1),
  becomes = c(strtoi(00000100, base = 2), strtoi(00001000, base = 2))
)

```

Now I can reclassify the MaxEnt outputs. I will load in the averaged predictions for the global and regional models and reclassify their values based on the two matrices above.

```{r reclassify maxent outputs}

if(FALSE) {

  # path to directory I will be working in
   mypath <- file.path(here::here() %>% 
                          dirname(),
                        "maxent/models")
  
   
  
  # reclassify and write regional raster
  v5_regional2 <- terra::classify(x = v5_regional1, 
                                  rcl = regional_classes,
                                  right = NA, # close both ends of the range of classification values
                                  others = NA,
                                  filename = file.path(mypath, "working_dir", "Lycorma_delicatula_avg_binary_v5_regional.asc"), # also write to file
                                  overwrite = FALSE) 

  # check minmax again
  terra::minmax(v5_regional2) %>%
    format(., scientific = FALSE)
  
  
  
  
  
  
  # reclassify and write global raster
  v5_global2 <- terra::classify(x = v5_global1, 
                                rcl = global_classes, 
                                right = NA, 
                                others = NA,
                                filename = file.path(mypath, "working_dir", "Lycorma_delicatula_avg_binary_v5_global.asc"), 
                                overwrite = FALSE) 

  # check minmax again
  terra::minmax(v5_global2) %>%
    format(., scientific = FALSE)
  
}

```

Now that the rasters have been converted to binary, we will visualize them to ensure that the process worked. Since the same process was done to both the regional and global models, I will only plot the regional model because it is smaller and will take far less time to render.

```{r prepare for plotting}

# path to directory I will be working in
mypath <- file.path(here::here() %>% 
                          dirname(),
                        "maxent/models")

# load in binary raster just created and convert to df
v5_regional2_df <- terra::rast(x = file.path(mypath, "working_dir", "Lycorma_delicatula_avg_binary_v5_regional.asc")) %>%
  terra::as.data.frame(., xy = TRUE) %>%
  na.omit()

# check for the number of unique values in the raster values column
unique(v5_regional2_df$v5_regional)
# it seems that the reclassification worked! Lets map it to be sure.


# first, convert NA values to 1 (unsuitable)
v5_regional2_df$v5_regional[is.na(v5_regional2_df$v5_regional)] <- 1

# now, create vectors of values used to manually edit the scale of the plot
# the possible values of the scale and their order
breaks.obj <- unique(v5_regional2_df$v5_regional)
# labels for the values
labels.obj <- c("unsuitable agreement", "suitable")
# vector of colors to classify scale
values.obj <- c(
  "azure4",
  "darkblue"
)

```

```{r plot binarized raster}

# plot regional binary
(v5_regional2_plot <- ggplot() +
  geom_raster(data = v5_regional2_df, 
              aes(x = x, y = y, fill = as.character(v5_regional))) +
  labs(title = "Predicted current regional niche for \n Lycorma delicatula (binary suitability)") +
  scale_discrete_manual(name = "suitability for SLF",
                        values = values.obj,
                        breaks = breaks.obj,
                        labels = labels.obj,
                        aesthetics = "fill") +
  map_style
)
  
# plot regional raw
(v5_regional_raw_plot <- ggplot() +
  geom_raster(data = terra::as.data.frame(v5_regional1, xy = TRUE), 
              aes(x = x, y = y, fill = as.character(Lycorma_delicatula_avg))) +
  labs(title = "Predicted current regional niche for \n Lycorma delicatula") +
  map_style
)

```

From the plots, we see that the binary conversion worked. Next, I will need to stack the reclassified global and regional rasters and add them into a single raster output. This should give me the a raster with 4 classes (Unsuitable Agreement = 5, Suitable Agreement = 10, unsuitable regional/suitable global = 9, Suitable regional/unsuitable global = 6. The mosaic function combines spatRasters that overlap in extent into a new raster, via the function specified (addition, in this case).

```{r mosaic rasters}

if(FALSE) {
  
  mypath <- file.path(here::here() %>% 
                          dirname(),
                        "maxent/models/working_dir")
  
  # load in reclassified global raster
  v5_global3 <- terra::rast(x = file.path(mypath, "Lycorma_delicatula_avg_binary_v5_global.asc"))
  
  # load in reclassified regional raster
  v5_regional3 <- terra::rast(x = file.path(mypath, "Lycorma_delicatula_avg_binary_v5_regional.asc"))
  
  
  
  # overlay and combine rasters by summing values
  v5_avg_binary_summed <- terra::mosaic(v5_global3, v5_regional3, 
                                      fun = "sum", 
                                      filename = file.path(mypath, "v5_avg_binary_summed.asc"),
                                      overwrite = FALSE,
                                      wopt = c(progress = 1)) # progress bar

}

```

Finally, I will need to overlay all SLF points and classify their stage of invasion.

```{r prepare data for mapping}

# path to directory I will be working in
mypath <- file.path(here::here() %>% 
                          dirname(),
                        "maxent/models/working_dir")

v5_avg_binary_summed <- terra::rast(x = file.path(mypath, "v5_avg_binary_summed.asc")) 
# rename values
names(v5_avg_binary_summed) <- "v5_summed"
# convert to df
v5_avg_binary_summed_df <- terra::as.data.frame(v5_avg_binary_summed, xy = TRUE) %>%
  na.omit()

# check for the number of unique values in the raster values column
unique(v5_avg_binary_summed_df$v5_summed)
# it seems that the reclassification worked! Lets map it to be sure.

# some values did not convert correctly, so we will convert them manually
# areas unsuitable in the regional but were NA in the global
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == -9998] <- 5
# areas unsuitable in the global and NA in the regional (-9995)
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == -9995] <- 5
#  areas unsuitable in the regional but did not overlap in the global
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == 1] <- 5
# areas suitable in the regional but were NA in the global
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == -9997] <- 6
# areas suitable in the regional but did not overlap in the global
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == 2] <- 6
# areas suitable in the global but were NA in the regional
v5_avg_binary_summed_df$v5_summed[v5_avg_binary_summed_df$v5_summed == -9991] <- 9

# Now that the values are one of the four we were looking for, create objects for rescaling the map

# now, create vectors of values used to manually edit the scale of the plot
# the possible values of the scale and their order
breaks.obj <- unique(v5_avg_binary_summed_df$v5_summed)
# labels for the values
labels.obj <- c("unsuitable", "unsuitable regional / suitable global", "suitable regional / unsuitable global", "suitable")
# vector of colors to classify scale
values.obj <- c(
  "azure4",
  "darkblue",
  "darkred",
  "darkorange"
)

```

```{r plot summed raster with points}

# load in SLF point data
slf_all_points <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_v0_2023-07.csv"))

# plot with points
v5_summed_points_plot <- ggplot() +
  geom_raster(data = v5_avg_binary_summed_df, 
              aes(x = x, y = y, fill = as.character(v5_summed))) +
  geom_point(data = slf_all_points, 
             aes(x = x, y = y), color = "black", size = 0.1) +
  xlim(-133.593750, -52.294922) +
  ylim(25.085599, 55.304138) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE)) + # legend with 2 rows
  labs(title = "Predicted suitability in current global vs regional niche for SLF") +
  scale_discrete_manual(name = "suitability for SLF",
                        values = values.obj,
                        breaks = breaks.obj,
                        labels = labels.obj,
                        aesthetics = "fill") +
  map_style

```

```{r save summed raster with points}

ggsave(v5_summed_points_plot, filename = file.path(here(), "vignette-outputs", "figures", "v5_maxent_overlay_slfPoints_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

```{r plot raster without points}
  
# plot without points
v5_avg_binary_summed_plot <- ggplot() +
  geom_raster(data = v5_avg_binary_summed_df, 
              aes(x = x, y = y, fill = as.character(v5_summed))) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE)) + # legend with 2 rows
  labs(title = "Predicted suitability in current global vs regional niche for SLF") +
  scale_discrete_manual(name = "suitability for SLF",
                        values = values.obj,
                        breaks = breaks.obj,
                        labels = labels.obj,
                        aesthetics = "fill") + 
  map_style


```

```{r save summed raster without points}

ggsave(v5_avg_binary_summed_plot, filename = file.path(here(), "vignette-outputs", "figures", "v5_maxent_overlay.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```




# Appendix

## SLF and IVR scatter plots

I will color code these scatter plots by US state name. I will need to use `tidygeocoder::reverse_geocode()` to match the lat / lon data to a state name.

```{r find state names for lat/lon data}

# read in slf_suitability tibble to 
slf_suitability2 <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_suitability_maxent_v5.csv"))

slf_point_states <- tidygeocoder::reverse_geocode(.tbl = slf_suitability2, 
                                                  lat = y, long = x, 
                                                  full_results = TRUE, # give each element of the address in a column
                                                  method = "arcgis",
                                                  progress_bar = TRUE
                                                  )

# select only columns we care about
slf_point_states <- slf_point_states %>%
  select(ID:y, Subregion:RegionAbbr, Postal, CntryName)

# save output
write_csv(x = slf_point_states, file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_v0_2023-07_withSubregions.csv"))

```

```{r plot SLF suitability values}

slf_point_states2 <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_v0_2023-07_withSubregions.csv"))

# R color brewer palette object
plot.pal <- brewer.pal(12, "OrRd") 
plot.pal <- colorRampPalette(plot.pal)(24)

# plot
(slf_suitability_scatter_region <- ggplot() +
   geom_vline(xintercept = 0.5) + # midpoint line
   geom_vline(xintercept = 0.163, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in global model
   geom_hline(yintercept = 0.5) +  # midpoint line
   geom_hline(yintercept = 0.079, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in regional model
   geom_point(data = slf_point_states2, 
              aes(x = v5_global, y = v5_regional, color = Region),
              size = 1) +
   viridis::scale_color_viridis(discrete = TRUE, option = "D") +
   guides(color = guide_legend(override.aes = list(size = 2))) +
   ggtitle("suitability of known SLF points in global vs regional model") +
   labs(caption = "dashed lines represent the minimum suitablity threshold") +
   scatter_style
)

```

```{r save scatterplot}

ggsave(slf_suitability_scatter_region, filename = file.path(here(), "vignette-outputs", "figures", "slf_suitability_maxent_v5_plot_withStates_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

Now I will do the same thing for the IVR regions

```{r find state names for lat/lon data}

IVR_suitability2 <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "IVR_suitability_maxent_v5.csv"))

# reverse geocode to obtain lat/lon data
IVR_point_states <- tidygeocoder::reverse_geocode(.tbl = IVR_suitability2, 
                                                  lat = y, long = x, 
                                                  full_results = TRUE, # give each element of the address in a column
                                                  method = "arcgis",
                                                  progress_bar = TRUE
                                                  )

# select only columns we care about
IVR_point_states <- IVR_point_states %>%
  select(ID:y, Subregion:RegionAbbr, Postal, CntryName)

write_csv(x = IVR_point_states, file = file.path(here(), "vignette-outputs", "data-tables", "wineries_withSubregions.csv"))

```


```{r plot SLF suitability values}

IVR_point_states2 <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "wineries_withSubregions.csv"))

(IVR_suitability_scatter_region <- ggplot() +
   geom_vline(xintercept = 0.5) + # midpoint line
   geom_vline(xintercept = 0.163, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in global model
   geom_hline(yintercept = 0.5) +  # midpoint line
   geom_hline(yintercept = 0.079, linetype = "dashed", alpha = 0.3) + # minimum threshold of suitability in regional model
   geom_point(data = IVR_point_states2, 
              aes(x = v5_global, y = v5_regional, color = Region), 
              size = 1) +
    viridis::scale_color_viridis(discrete = TRUE, option = "D") +
   ggtitle("suitability of IVR regions for SLF establishment in global vs regional models") +
   theme(legend.position = "bottom") +
    guides(color = guide_legend(title = "State Name", ncol = 2, override.aes = list(size = 2))) +
   labs(caption = "dashed lines represent the minimum suitablity threshold") +
   scatter_style 
)

```

```{r save scatterplot}

ggsave(IVR_suitability_scatter_region, filename = file.path(here(), "vignette-outputs", "figures", "IVR_suitability_maxent_v5_plot_withStates_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

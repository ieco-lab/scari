---
title: "Setup for regional MaxEnt Models"
author: "Samuel M. Owens"
contact: "sam.owens@temple.edu"
date: "2024-01-05"
output: html_document
---
# Overview

In the previous vignette, I ran the global model, which was an important first step to examine suitability for SLF at multiple spatial scales. In this vignette, I will set up to run two models at the spatial scale of particular regions. I will run two models; one model will be run based on data from the native range (China) and the other will be based on data from the invaded range in North America. We hypothesize that by creating models at multiple spatial scales, we can have more confidence in suitability predictions made for specific SLF populations and important viticultural regions, and can predict the risk of specific populations spreading now and under climate change.

(EXPAND)

This vignette will set up for the regional model in a similar fashion to the setup I created for the global model in vignette 040. Step 1 will involve cropping the bioclim layers to the proper extent and step 2 will involve choosing the background points for each regional model. Note that background point choice for the regional_invaded model will be weighted by the output of the global model, but the background point choice for the regional_native model will not be. This is to account for the fact that SLF have likely not had ample time to spread to all suitable areas within the invaded range. MaxEnt assumes that all training areas (in our case, the eastern USA) are equally as likely to host lanternfly, whereas we know this is not the case because SLF was introduced to this region within the past decade. Weighting our regional predictions with a prediction made using all available data should offset this incorrect assumption.

Here is the table summarizing the model structures:

```{r model_info table}

model_info <- data.frame(
  "model" = c(
    "global",
    "regional_native",
    "regional_invaded"
    ),
  "train_data" = c(
    "80% of global presences, k-fold random cross validation",
    "SLF presences in mainland China",
    "SLF presences in North America"
  ),
  "number_train_points" = c(
    "619",
    "237",
    "328"
  ),
  "test_data" = c(
    "20% of global presences, k-fold random cross validation",
    "SLF presences in North America",
    "SLF presences in mainland China"
  ),
  "number_test_points" = c(
    "155",
    "328",
    "237"

  ),
  "projection" = "North America",
  "number_background_points" = c(
    "20,000",
    "10,000",
    "10,000"
  )
)

model_info_kable <- knitr::kable(x = model_info)
  
```

Here is a table that lists the extents I will use to trim the bioclim layers.

```{r extents table}

extents <- data.frame(
  "spatial_extent" = c("global model training", "invaded_regional model training", "native_regional model training", "projection"),
  "long_min" = c(-180, -96.504, 89.43514, -140.977),
  "long_max" = c(179, -59.590, 126.05626, -51.064),
  "lat_min" = c(-60, 23.5, 20.23827, 15.182),
  "lat_max" = c(83, 47.458, 53.32406, 60.589)
)

extents_kable <- knitr::kable(x = extents)
  
```

# Setup

I will prepare for this vignette by loading the necessary packages to run this script. I will also be creating maps during this analysis, so I will create a list object containing a standardized map style that I will continue to use.

```{r load necesssary packages, echo = FALSE}

# general tools
library(tidyverse)  #data manipulation
library(here) #making directory pathways easier on different instances
here() # here() starts at the root folder of this package.
library(devtools)

library(dismo) # generate random background points

# spatial data handling
library(raster) 
library(terra)
library(sf)

# spatial data sources
library(rnaturalearth)
# remotes::install_github("ropensci/rnaturalearthhires")
library(rnaturalearthhires)

# aesthetics
# devtools::install_github("slowkow/ggrepel")
library(ggrepel)

```

```{r ggplot object for map style}

map_style <- list(
  xlab("longitude"),
  ylab("latitude"),
  theme_classic(),
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
  ),
  scale_x_continuous(expand = c(0, 0)),
  scale_y_continuous(expand = c(0, 0)),
  labs(fill = "Suitability for SLF"),
  viridis::scale_fill_viridis(option = "D"),
  coord_equal()
)

```

# 1. Trim Bioclim layers

```{r set wd}

# path to directory
  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

```{r layers to be cropped}

# lists of target files in the directory
# load in bioclim layers to be cropped- the 10km .asc files
env.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = TRUE) %>%
# extract the 4 bioclim layers I will be using in my models. Access to cities will not be used until later models
  grep("atc_2015_global.asc|bio2_1981-2010_global.asc|bio11_1981-2010_global.asc|bio12_1981-2010_global.asc|bio15_1981-2010_global.asc", ., value = TRUE)


```


## Invaded regional (eastern USA)

```{r setup for cropping bioclim layers}

# output file names
output.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = FALSE) %>%
  grep("atc_2015_global|bio2_1981-2010_global|bio11_1981-2010_global|bio12_1981-2010_global|bio15_1981-2010_global", ., value = TRUE) %>%
  gsub(pattern = "global", replacement = "easternUSA")

# extent object for eastern USA
ext.obj <- terra::ext(-96.503906, -59.589844, 23.5, 47.457809)

```

These rasters need to be cropped and converted to the .ascii format for MaxEnt.

```{r loop to crop bioclim layers to easternUSA}

# view list of filetypes for terra, use .ascii
View(terra::gdal(drivers = TRUE))

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::crop(x = rast.hold, y = ext.obj, overwrite = FALSE)
    
    #write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

# I am pretty sure this method resets the raster cell numbers, which might be annoying downstream....

```

Lets plot one of the new layers to make sure the cropping worked.

```{r plot main_layer to ensure cropping worked}

bio11 <- terra::rast(x = file.path(mypath, "bio11_1981-2010_easternUSA.asc")) 
# convert to df
bio11_df <- terra::as.data.frame(bio11, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```


## Invaded regional (South Korea and Japan)

```{r set wd}

  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

```{r rnaturalearth download}

# check which types of data are available
# these are in the rnaturalearth package
data(df_layers_cultural) 
# I will use states_provinces

# get metadata
ne_metadata <- ne_find_vector_data(
  scale = 10,
  category = "cultural",
  getmeta = TRUE
) %>%
  dplyr::filter(layer == "admin_0_countries")
# URL to open metadata
utils::browseURL(ne_metadata[, 3])


# download data
invaded_asian <- rnaturalearth::ne_download(
  scale = 10, # highest resolution
  type = "admin_0_countries", # states and provinces
  category = "cultural",
  destdir = file.path(here(), "data-raw", "ne_countries"),
  load = TRUE, # load into environment
  returnclass = "sf" #terra spatvector
)

```

```{r ready data for intersect}

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  sf::st_as_sf(coords = c("x", "y")) # convert to sf object

# set crs
sf::st_crs(slf_points) <- "EPSG:4326"
  


# china shapefile  
invaded_asian <- invaded_asian %>%
  dplyr::filter(NAME %in% c("Japan", "South Korea")) %>%
  # set crs
  sf::st_transform(x = ., dst = "EPSG:4326") 

```

```{r intersect and save}

# intersect
invaded_asia_withSLF <- sf::st_filter(x = invaded_asian, y = slf_points) 

# also retrieve bounding box for records
sf::st_bbox(invaded_asia_withSLF)

# list of writing drivers for sf
sf::st_drivers()
# write to file
sf::st_write(
  obj = invaded_asia_withSLF, 
  dsn = file.path(here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"),
  driver = "ESRI Shapefile"
  )


```

```{r re-load shapefile as needed}

invaded_asia_withSLF <- sf::read_sf(dsn = file.path(here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"))

```

Now lets plot it for a sanity check.

```{r plot invaded_asian range}

(invaded_asian_map <- ggplot() +
   # world map
   geom_polygon(data = map_data('world', region = c("Japan", "South Korea")), aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # slf native range shapefile
   geom_sf(data = invaded_asia_withSLF, fill = "darkorange", color = "black") +
   # scales
   xlab("longitude") +
   ylab("latitude") +
   labs(title = "SLF invaded range in Asia") +
   theme_classic()
)
```

```{r save plot}

ggsave(invaded_asian_map, 
       filename = file.path(here(), "vignette-outputs", "figures", "SLF_regional_invaded_asian_extent.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
)

```

```{r load in data}

# load in shapefile as spatVector for compatibility
invaded_asian_withSLF <- terra::vect(x = file.path(here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"))

# rasters were loaded in above

# set naming for rasters
output.files <- list.files(path = file.path(mypath), pattern = "\\_global.asc$", full.names = FALSE) %>%
  gsub(pattern = "global", replacement = "invaded_asian")

```

```{r mask}

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::mask(x = rast.hold, mask = invaded_asian_withSLF)
    
    # write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

```

```{r plot for check}

bio11_invaded_asian <- terra::rast(x = file.path(mypath, "bio11_1981-2010_invaded_asian.asc")) 
# convert to df
bio11_invaded_asian_df <- terra::as.data.frame(bio11_invaded_asian, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_invaded_asian_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```



## Native regional (China)

The native range for China will be defined as any Chinese province that contains known SLF populations. We will exclude Vietnam, Thailand India and Bangaladesh due to a lack of data (discussed later). For now, we will need to find a shapefile of the Chinese provinces to use for the regional_native model.

### Get shapefile for native range

```{r rnaturalearth download}

# check which types of data are available
data(df_layers_cultural) 
# I will use states_provinces

# get metadata
ne_metadata <- ne_find_vector_data(
  scale = 10,
  category = "cultural",
  getmeta = TRUE
) %>%
  dplyr::filter(layer == "admin_1_states_provinces")
# URL to open metadata
utils::browseURL(ne_metadata[, 3])


# download data
china_provinces <- rnaturalearth::ne_download(
  scale = 10, # highest resolution
  type = "admin_1_states_provinces", # states and provinces
  category = "cultural",
  #destdir = file.path(here(), "data-raw", "ne_states_provinces"),
  #load = TRUE, # load into environment
  returnclass = "sf" #terra spatvector
)

```

Now that we have the data, we can cut out the parts we want. We can treat the shapefile like any other data table and simply cut out the Chinese provinces. 

```{r ready data for intersect}

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  sf::st_as_sf(coords = c("x", "y")) # convert to sf object

# set crs
sf::st_crs(slf_points) <- "EPSG:4326"
  


# china shapefile  
china_provinces <- china_provinces %>%
  dplyr::filter(geonunit == "China") %>%
  # set crs
  sf::st_transform(x = ., dst = "EPSG:4326") 

# copy of china shapefile with extra province selected (for later)
china_guangxi <- china_provinces %>%
  dplyr::filter(name == "Guangxi")

```

We will keep only the provinces of China that contain SLF points (plus Guangxi, which is explained later). We will perform an intersect between the vectorized SLF points and the provinces shapefiles.

```{r intersect and save}

# intersect
china_provinces_withSLF <- sf::st_filter(x = china_provinces, y = slf_points) %>%
  # add Guangxi province
  dplyr::bind_rows(., china_guangxi)

# also retrieve bounding box for records
sf::st_bbox(china_provinces_withSLF)

# list of writing drivers for sf
sf::st_drivers()
# write to file
sf::st_write(
  obj = china_provinces_withSLF, 
  dsn = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"),
  driver = "ESRI Shapefile"
  )


```

```{r re-load shapefile as needed}

china_provinces_withSLF <- sf::read_sf(dsn = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"))

```

Now lets plot it for a sanity check.

```{r plot china}

(native_map <- ggplot() +
   # world map
   geom_polygon(data = map_data('world', region = "China"), aes(x = long, y = lat, group = group), fill = "azure4", color = "black", lwd = 0.15) +
   # slf native range shapefile
   geom_sf(data = china_provinces_withSLF, fill = "darkorange", color = "black") +
   # geom_sf_label(data = china_provinces_withSLF, aes(label = name), size = 2, position = "dodge") +
   ggrepel::geom_label_repel(
     data = china_provinces_withSLF, 
     aes(geometry = geometry, label = name), 
     stat = "sf_coordinates", 
     size = 3, 
     label.size = 0.75,
     linewidth = 1
     ) +
   xlab("longitude") +
   ylab("latitude") +
   labs(title = "Native range for SLF (Chinese provinces containing SLF records)",
        caption = "NOTE: Guangxi did not contain SLF presences, but was added based on expert opinion") +
   theme_classic()
)
```

```{r save plot}

ggsave(native_map, 
       filename = file.path(here(), "vignette-outputs", "figures", "SLF_native_range_extent_v1.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
)

```

This plotted range roughly corresponds to surveys of SLF performed in the literature. Xin et al performed a rigorous survey of SLF populations across China for biocontrol purposes (Xin et al, 2020). [Here](https://academic.oup.com/view-large/figure/228296055/nvaa137_fig1.jpg) is a figure of the study sites where they retrieved SLF populations. They also mapped the population density to a map of the Chinese provinces [here](https://academic.oup.com/view-large/figure/228296047/nvaa137_fig6.jpg?itm_medium=graphical+abstract+image&itm_content=open+image&itm_source=http://academic.oup.com/ee/article/50/1/36/6029751&itm_campaign=graphical+abstract). Our map roughly corresponds to the native extent of SLF, as surveyed by this study. 

Another study by Du et al surveyed SLF populations to explain the phylogenetic origins of invasive SLF populations (Du et al, 2021). Du et al took measures to ensure that SLF populations surveyed for their study represented established populations and they specifically surveyed egg masses (Du et al, 2021). Our range map also corresponds to the map of surveyed populations in [figure 1](https://academic.oup.com/view-large/figure/228296047/nvaa137_fig6.jpg?itm_medium=graphical+abstract+image&itm_content=open+image&itm_source=http://academic.oup.com/ee/article/50/1/36/6029751&itm_campaign=graphical+abstract). 

Our native range map included three additional provinces, two in the far south (Guangdong and Guangxi) and one at the western edge (Qinghai). Guangxi was added manually based on expert opinion of SLF presence (Matthew Helmus, PhD). The other two provinces (Guangdong and Quighai) were added due to due to additional SLF records that we retrieved, likely from our literature search outlined in vignette 020. This range map will represent the native range training area for our native regional model. Background points will be chosen specifically from this region of China. Other countries have been named as part of the SLF native range (India, Vietnam, Taiwan, Bangaladesh), but no data exists to support these claims, so we chose to be conservative with our consideration of the SLF native range (SOURCE). Our consideration of the SLF native range also corresponds with the above mentioned surveys for SLF. 

* *NOTE* inaturalist contains a single SLF presence in Taiwan, but this data point was not licensed for re-use and so we chose not to include it. Otherwise, no SLF presence data could be found in any data repository (GBIF, inaturalist) or the literature for the countries we chose to exclude from the SLF native range.*

### Use shapefile to create rasters for SLF native range

I will use the above env.files and output.files objects to load in the bioclim rasters. I will then mask them using the shapefile I created in the last step.

```{r load in data}

# load in shapefile as spatVector for compatibility
china_provinces_withSLF <- terra::vect(x = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"))

# rasters were loaded in above

# set naming for rasters
output.files <- list.files(path = file.path(mypath), pattern = "\\.asc$", full.names = FALSE) %>%
  grep("atc_2015_global|bio2_1981-2010_global|bio11_1981-2010_global|bio12_1981-2010_global|bio15_1981-2010_global", ., value = TRUE) %>%
  gsub(pattern = "global", replacement = "China")

```

```{r mask}

if(FALSE) {
  
  # loop to crop extent for all files
  for(a in seq_along(env.files)){

    #ensure that the CRS is consistent
    rast.hold <- terra::rast(env.files[a])
    
    # crop new rasters to extent
    rast.hold <- terra::mask(x = rast.hold, mask = china_provinces_withSLF)
    
    # write out the new resampled rasters!
    terra::writeRaster(x = rast.hold, filename = file.path(mypath, output.files[a]), filetype = "AAIGrid", overwrite = FALSE)
    
    # remove object once its done
    rm(rast.hold)
    
  }
  
}

```

```{r plot for check}

bio11_china <- terra::rast(x = file.path(mypath, "bio11_1981-2010_China.asc")) 
# convert to df
bio11_china_df <- terra::as.data.frame(bio11_china, xy = TRUE)

# plot main layer as example
(ggplot() +
  # change scale of plots to be standard across figures
  geom_raster(data = bio11_china_df, 
            aes(x = x, y = y, fill = `CHELSA_bio11_1981-2010_V.2.1`)) +
  xlab("longitude") +
  ylab("latitude") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_equal()
)
# the cropping worked

```

Now we have the input bioclim rasters for the regional_invaded model cropped and masked to the proper extent. This concludes our raster work. 

We will need to select background points for both the native and invaded regional models, which we will do next.

# 2. Background point choice

```{r set wd}

  mypath <- file.path(here() %>% 
                       dirname(),
                     "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

```

## Invaded Regional (eastern USA)

```{r load datasets}

# load in raster to choose points from
easternUSA_bio11 <- raster::raster(x = file.path(mypath, "bio11_1981-2010_easternUSA.asc")) 

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  as.data.frame()

```

Now, select random points. These will be corrected for the latitudinal stretching and will not be selected from presence locations, like with the global model. 

```{r random points}

# set seed
set.seed(5)

# generate random points 
regional_invaded_background <- dismo::randomPoints(
  mask = easternUSA_bio11, # cropped to eastern USA
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(
  x = regional_invaded_background, 
  file = file.path(here(), "vignette-outputs", "data-tables", "regional_invaded_background_points_unweighted.csv")
  )
# save as rds file
write_rds(
  regional_invaded_background, 
  file = file.path(here(), "data", "regional_invaded_background_points_unweighted.rds")
  )

```

Now lets visualize the result.

```{r plotting datasets}

easternUSA_bio11_df <- terra::rast(x = file.path(mypath, "bio11_1981-2010_easternUSA.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

# extent object for eastern USA
ext.obj <- terra::ext( -140.976563, -51.064453, 15.182421, 60.586967)

# load in raster for visualization
global_atc <- terra::rast(x = file.path(mypath, "atc_2015_global.asc")) %>%
  # crop to easternUSA
  terra::crop(., y = ext.obj)
# convert to df
global_atc_df <- terra::as.data.frame(global_atc, xy = TRUE)

```


```{r plot}

# plot at the continental scale
(regional_invaded_background_plot <- ggplot() +
   geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
   geom_raster(data = easternUSA_bio11_df, aes(x = x, y = y), fill = "azure1") +
   geom_point(data = regional_invaded_background, aes(x = x, y = y), color = "firebrick2", size = 0.001) +
   scale_x_continuous(expand = c(0, 0)) +
   scale_y_continuous(expand = c(0, 0)) +
   labs(
     title = "'regional_invaded' model background points", 
     x = "longitude",
     y = "latitude"
     ) +
   theme_classic() +
   theme(
     legend.position = "none",
     panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
     ) + 
   coord_equal() 
)

```

We can see that the background points are isolated to the eastern half of the United States and some of Canada. This is what we want because the model will be trained on this area. We can also see that points were selected from areas where the model did not predict high suitability (most highly suitable areas were near PA and NJ). For comparison, this figure is roughly opposite of the figure depicting the suitability values for the mean output from the global model.  

```{r save plot}

ggsave(
  regional_invaded_background_plot, 
  filename = file.path(here(), "vignette-outputs", "figures", "regional_invaded_model_background_points_unweighted.jpg"),
  height = 8, 
  width = 12,
  device = "jpeg",
  dpi = "retina"
  )

```


## invaded Regional (South Korea and Japan)

```{r load datasets}

# load in raster to choose points from
invaded_asian_bio11 <- raster::raster(x = file.path(mypath, "bio11_1981-2010_invaded_asian.asc")) 

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) %>%
  as.data.frame()

```

```{r random points}

# set seed
set.seed(7)

# generate random points 
regional_invaded_asian_points <- dismo::randomPoints(
  mask = invaded_asian_bio11, # cropped to regional_invaded_asian range
  n = 5000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(x = regional_invaded_asian_points, file = file.path(here(), "vignette-outputs", "data-tables", "regional_invaded_asian_background_points_unweighted.csv"))
# save as rds file
write_rds(regional_invaded_asian_points, file = file.path(here(), "data", "regional_invaded_asian_background_points_unweighted.rds"))

```

Now lets visualize the result.

```{r load in data for plotting}

invaded_asian_df <- terra::rast(
  x = file.path(mypath, "atc_2015_invaded_asian.asc")
  ) %>%
  terra::as.data.frame(., xy = TRUE)

global_atc_df <- terra::rast(x = file.path(mypath, "atc_2015_global.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

regional_invaded_asian_points <- read.csv(file = file.path(here(), "vignette-outputs", "data-tables", "regional_invaded_asian_background_points_unweighted.csv"))

```

```{r plot}

(regional_invaded_asian_points_plot <- ggplot() +
   geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
   geom_raster(data = invaded_asian_df, aes(x = x, y = y), fill = "azure1") +
   geom_point(data = regional_invaded_asian_points, aes(x = x, y = y), color = "firebrick2", size = 0.1) +
   ggtitle("'regional_invaded_asian' model background points") +
   map_style +
   theme(legend.position = "none") +
   coord_equal(xlim = c(122.93816, 153.98561), ylim = c(24.21210, 45.52041))
)

```

We can see that the background points are isolated to the eastern half of the United States and some of Canada. This is what we want because the model will be trained on this area. We can also see that points were selected from areas where the model did not predict high suitability (most highly suitable areas were near PA and NJ). For comparison, this figure is roughly opposite of the figure depicting the suitability values for the mean output from the global model.  

```{r save plot}

ggsave(regional_invaded_asian_points_plot, 
       filename = file.path(here(), "vignette-outputs", "figures", "regional_invaded_asian_model_background_points_unweighted.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina"
       )

```


## Native regional (China)

I need to select points for China as well, but I do not need to weight these. The background selection here will be random, but will still exclude cells with SLF points and will correct for latitudinal stretching.

```{r set wd}

# path to directory
mypath <- file.path(here() %>% 
                     dirname(),
                   "maxent")

```

```{r load in datasets}

# slf points
slf_points <- read.csv(file = file.path(here(), "vignette-outputs", "data-tables", "slf_all_final_coords_2024-02-01.csv")) %>%
   dplyr::select(-species) 

# mask layer I will use
China_bio2 <- raster::raster(x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "bio2_1981-2010_China.asc"))

```

```{r background points for global models}

# set seed so that the random points for this dataset are the same the next time this code is run
set.seed(6)
# generate random points 
China_points <- dismo::randomPoints(
  mask = China_bio2, 
  n = 10000, # default number used by maxent
  p = slf_points,
  excludep = TRUE, # exclude cells where slf has been found
  lonlatCorrection = TRUE, # weight samples by latitude because cell size is larger closer to equator
  warn = 2 # higher number gives most warnings, including if sample size not reached
  ) %>%
  as.data.frame(.)

# save as csv
write_csv(x = China_points, file = file.path(here(), "vignette-outputs", "data-tables", "regional_native_background_points_v0.csv"))
# save as rds file
write_rds(China_points, file = file.path(here(), "data", "regional_native_background_points_v0.rds"))
  
  
```

Now, I will plot these points for visualization purposes.

```{r load in files for plotting}

mypath <- file.path(here() %>% 
                     dirname(),
                   "maxent/historical_climate_rasters/chelsa2.1_30arcsec/v1_maxent_10km")

China_bio2_df <- terra::rast(x = file.path(mypath, "bio2_1981-2010_China.asc")) %>%
  terra::as.data.frame(., xy = TRUE)

regional_native_points <- read_csv(file = file.path(here(), "vignette-outputs", "data-tables", "regional_native_background_points_v0.csv"))

```

```{r plot points}

native_points_plot <- ggplot() +
  geom_polygon(data = map_data('world', region = "China"), aes(x = long, y = lat, group = group), fill = "azure4") +
  geom_raster(data = China_bio2_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = regional_native_points, aes(x = x, y = y), color = "firebrick2", size = 0.1) +
  ggtitle("'regional_native' model background points") +
  map_style +
  theme(legend.position = "none") 

```

The points seem to sufficiently cover the global extent. I can also see the latitude weighting, as the areas nearest the poles are less densely covered with points than areas near the equator.

```{r save plot}

ggsave(native_points_plot, 
       filename = file.path(here(), "vignette-outputs", "figures", "regional_native_model_background_points_v0.jpg"),
       height = 8, 
       width = 10,
       device = "jpeg",
       dpi = "retina")

```

# 3. Plot SLF presences 

```{r read in SLF presences}

# load in slf points to intersect
slf_points <- read_rds(file = file.path(here(), "data", "slf_all_final_coords_2024-02-01.rds")) %>%
  dplyr::select(-species) 

```

## Invaded Regional (eastern USA)

Finally, I will create a plot of all SLF presence locations for reference.

```{r filter presences from invaded range}

# extent object for eastern USA
ext.obj <- terra::ext(-96.503906, -59.589844, 23.5, 47.457809)

# convert to vector
slf_points_vect <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
  # crop by extent area of interest
  terra::crop(., y = ext.obj) %>%
  # convert to geom, which gets coordinates of a spatVector
  terra::geom() 

# convert back to data frame
slf_points_invaded <- terra::as.data.frame(slf_points_vect) %>%
  dplyr::select(-c(geom, part, hole))

# will not need this object again
rm(slf_points_vect)

```

```{r plot model presences}

# load in raster
easternUSA <- terra::rast(
  x = file.path(mypath, "historical_climate_rasters", "chelsa2.1_30arcsec", "v1_maxent_10km", "atc_2015_easternUSA.asc")
  )
# also convert to df
easternUSA_df <- terra::as.data.frame(easternUSA, xy = TRUE)

# plot
regional_invaded_slf_plot <- ggplot() +
  geom_raster(data = global_mean_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = easternUSA_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_invaded, aes(x = x, y = y), color = "darkorange", size = 0.5) +
  labs(
    title = "'regional_invaded' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal()
  

```

```{r save plot}

ggsave(
  regional_invaded_slf_plot, 
  filename = file.path(here(), "vignette-outputs", "figures", "regional_invaded_model_presence_points.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

## Invaded Regional (South Korea and Japan)

```{r filter presences from invaded_asian range}

# native range extent shapefile used to select slf presences
mask_layer <- terra::vect(x = file.path(here(), "vignette-outputs", "shapefiles", "SLF_regional_invaded_asian_extent.shp"))

# convert to vector
slf_points_masked <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
# crop by extent area of interest
terra::mask(., mask = mask_layer) %>%
# convert to geom, which gets coordinates of a spatVector
terra::geom() 

# convert back to data frame
slf_points_invaded_asian <- terra::as.data.frame(slf_points_masked) %>%
  dplyr::select(-c(geom, part, hole))
  
# will not need this object again
rm(slf_points_masked)

```

```{r plot model presences}

regional_invaded_asian_slf_plot <- ggplot() +
  geom_raster(data = global_atc_df, aes(x = x, y = y), fill = "azure4") +
  geom_raster(data = invaded_asian_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_invaded_asian, aes(x = x, y = y), color = "darkorange", size = 1) +
  labs(
    title = "'regional_invaded_asian' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal(xlim = c(122.93816, 153.98561), ylim = c(24.21210, 45.52041))
  

```

```{r save plot}

ggsave(
  regional_invaded_asian_slf_plot, 
  filename = file.path(here(), "vignette-outputs", "figures", "regional_invaded_asian_model_presence_points.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

## Native Regional

```{r filter presences from native range}

# native range extent shapefile used to select slf presences
mask_layer <- terra::vect(x = file.path(here(), "vignette-outputs", "shapefiles", "SLF_native_range_extent.shp"))

# convert to vector
slf_points_masked <- terra::vect(x = slf_points, geom = c("x", "y"), crs = "EPSG:4326") %>%
# crop by extent area of interest
terra::mask(., mask = mask_layer) %>%
# convert to geom, which gets coordinates of a spatVector
terra::geom() 

# convert back to data frame
slf_points_native <- terra::as.data.frame(slf_points_masked) %>%
  dplyr::select(-c(geom, part, hole))
  
# will not need this object again
rm(slf_points_masked)
rm(mask_layer)

```

```{r plot model presences}

regional_native_slf_plot <- ggplot() +
  geom_polygon(data = map_data('world', region = "China"), aes(x = long, y = lat, group = group), fill = "azure4") +
  geom_raster(data = China_bio2_df, aes(x = x, y = y), fill = "azure1") +
  geom_point(data = slf_points_native, aes(x = x, y = y), color = "darkorange", size = 0.5) +
  labs(
    title = "'regional_native' model SLF presences",
    x = "longitude",
    y = "latitude"
  ) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(panel.background = element_rect(fill = "lightblue2",
                                        colour = "lightblue2")
        ) +
  coord_equal()
  

```

```{r save plot}

ggsave(
  regional_native_slf_plot, 
  filename = file.path(here(), "vignette-outputs", "figures", "regional_native_model_presence_points.jpg"),
  height = 8, 
  width = 10,
  device = "jpeg",
  dpi = "retina"
  )

```

Now we are ready to run both regional models!


# References

Calvin, D. D., J. Rost, J. Keller, S. Crawford, B. Walsh, M. Bosold, and J. Urban. 2023. Seasonal activity of spotted lanternfly (Hemiptera: Fulgoridae), in Southeast Pennsylvania. Environmental Entomology 52:1108–1125.

Du, Z., Y. Wu, Z. Chen, L. Cao, T. Ishikawa, S. Kamitani, T. Sota, F. Song, L. Tian, W. Cai, and H. Li. 2021. Global phylogeography and invasion history of the spotted lanternfly revealed by mitochondrial phylogenomics. Evolutionary Applications.

Gallien, L., R. Douzet, S. Pratte, N. E. Zimmermann, and W. Thuiller. 2012. Invasive species distribution models – how violating the equilibrium assumption can create new insights. Global Ecology and Biogeography 21:1126–1136.

Lewkiewicz, S. M., S. De Bona, M. R. Helmus, and B. Seibold. 2022. Temperature sensitivity of pest reproductive numbers in age-structured PDE models, with a focus on the invasive spotted lanternfly. Journal of Mathematical Biology 85:29.

Santana Jr, P. A., L. Kumar, R. S. Da Silva, J. L. Pereira, and M. C. Picanço. 2019. Assessing the impact of climate change on the worldwide distribution of Dalbulus maidis (DeLong) using MaxEnt. Pest Management Science 75:2706–2715.

Xin, B., Y. Zhang, X. Wang, L. Cao, K. A. Hoelmer, H. J. Broadley, and J. R. Gould. 2020. Exploratory survey of spotted lanternfly (Hemiptera: Fulgoridae) and its natural enemies in China. Environmental Entomology 50:36–45.



